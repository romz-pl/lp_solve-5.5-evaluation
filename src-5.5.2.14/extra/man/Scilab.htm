<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<HEAD>
		<TITLE>Using lpsolve from Scilab</TITLE>
		<style TYPE="text/css"> BODY { font-family:verdana,arial,helvetica; margin:15; }
	</style>
	</HEAD>
	<BODY>
					<h1 align="left"><u>Using lpsolve from Scilab</u></h1>
<a name="Scilab"></a>
<h3>Scilab?</h3>
<P>Developed at INRIA, Scilab has been developed for system control and signal
processing applications. It is freely distributed in source code format.</P>

<P>Scilab is made of three distinct parts: an interpreter, libraries of
functions (Scilab procedures) and libraries of Fortran and C routines. These
routines (which, strictly speaking, do not belong to Scilab but are
interactively called by the interpreter) are of independent interest and most of
them are available through Netlib. A few of them have been slightly modified for
better compatibility with Scilab's interpreter. A key feature of the Scilab
syntax is its ability to handle matrices: basic matrix manipulations such as
concatenation, extraction or transpose are immediately performed as well as
basic operations such as addition or multiplication. Scilab also aims at
handling more complex objects than numerical matrices. For instance, control
people may want to manipulate rational or polynomial transfer matrices. This is
done in Scilab by manipulating lists and typed lists which allows a natural
symbolic representation of complicated mathematical objects such as transfer
functions, linear systems or graphs.</P>

<P>Polynomials, polynomials matrices and transfer matrices are also defined and
the syntax used for manipulating these matrices is identical to that used for
manipulating constant vectors and matrices.</P>

<P>Scilab provides a variety of powerful primitives for the analysis of
non-linear systems. Integration of explicit and implicit dynamic systems can be
accomplished numerically. The <TT>scicos</TT> toolbox allows the graphic
definition and simulation of complex interconnected hybrid systems.</P>

<P>Scilab has an open programming environment where the creation of functions
and libraries of functions is completely in the hands of the user.
Functions are recognized as data
objects in Scilab and, thus, can be manipulated or created as other data
objects. For example, functions can be defined inside Scilab and passed as input
or output arguments of other functions.</P>

<P>In addition Scilab supports a character string data type which, in
particular, allows the on-line creation of functions. Matrices of character
strings are also manipulated with the same syntax as ordinary matrices.</P>

<P>Finally, Scilab is easily interfaced with Fortran or C subprograms. This
allows use of standardized packages and libraries in the interpreted environment
of Scilab.</P>

<P>The general philosophy of Scilab is to provide the following sort of
computing environment:</P>

<UL>
<LI>To have data types which are varied and flexible with
  a syntax which is natural and easy to use.

<LI>To provide a reasonable set of primitives which serve
  as a basis for a wide variety of calculations.

<LI>To have an open programming environment where new primitives are easily
added. A useful tool distributed with Scilab is <TT>intersci</TT> which is a tool for building interface
  programs to add new primitives i.e. to add new modules of Fortran or C code
  into Scilab.

<LI>To support library development through ``toolboxes'' of functions devoted to
specific applications (linear control, signal processing, network analysis,
non-linear control, etc.)</LI>
</UL>

<p>We will not discuss the specifics of Scilab here but instead refer the reader to the
<a href="http://scilabsoft.inria.fr/">Scilab</a> website and
<a href="http://scilabsoft.inria.fr/product/index_product.php?page=old_documentation.html">documentation</a>.
</p>

<a name="Scilab_and_lpsolve"></a>
<h3>Scilab and lpsolve</h3>

<p>lpsolve is callable from Scilab via an external interface. As such, it looks like lpsolve is fully integrated
with Scilab. Matrices can directly be transferred between Scilab and lpsolve in both directions. The complete interface
is written in C so it has maximum performance. The whole lpsolve API is implemented with some extra's specific for
Scilab (especially for matrix support). So you have full control to the complete lpsolve functionality via the sclpsolve
Scilab driver. If you find that this involves too much work to solve an lp model then you can also work via higher-level
scripts that can make things a lot easier. See further in this article.
</p>

<a name="Quickstart"></a>
<h3>Quickstart</h3>
<pre>
Compile and build sclpsolve:
----------------------------<OL><LI>Get the needed sources and libraries:
Archive lp_solve_5.5.2.14_scilab_source.tar.gz contains the sources to build sclpsolve.
Uncompress it to a directory, for example d:\lp_solve. Make sure that the folder structure is kept.
It will create a directory structure lp_solve_5.5\extra\scilab\lpsolve in that folder.
Archive lp_solve_5.5.2.14_dev.zip (Windows) or lp_solve_5.5.2.14_dev.tar.gz (Unix) contains
needed libraries and include files to link the sources with.
Uncompress it to the same folder as for the sources, appended with lp_solve_5.5.
In this example that would be d:\lp_solve\lp_solve_5.5
You have now all needed files in place.
In your chosen directory (in this example d:\lp_solve) there will only be a directory lp_solve_5.5
In this directory, you have a directory extra and some files ending with .h and .lib
The extra directory contains a scilab directory which contains a directory lpsolve with some files and directories.
Under Windows, the lpsolve library lpsolve55.lib must be available in the lpsolve55 directory.
However older version of scilab (&lt;=3.0) require that this file is called lpsolve55.ilib
In that case copy lpsolve55.lib to lpsolve55.ilib</LI>
<LI>Under Windows, the Microsoft Visual C/C++ compiler must be installed
and the environment variables must be active so that when a command prompt
is opened, the cl and nmake commands can be executed. This can be done also by opening
a command prompt and execute the batch file VCVARS32.BAT (somewhere on your system)
and then starting scilab from that same command prompt.
Under Unix/Linux, the standard c compiler is used so no special things must be done.</LI>
<!--
<LI>Edit the file Path.incl (under lp_solve_5.5\extra\scilab\lpsolve) and change pathnames as needed:
 SCIDIR and SCIDIR1: two times the folder where scilab is installed. For example F:\Program Files\scilab-4.1.2
 LPSOLVEDIR and LPSOLVELIBDIR: the folder where you uncompressed the scilab source archive into appened with \lp_solve_5.5.
                               In this example d:\lp_solve\lp_solve_5.5</LI>
//--><LI>Start Scilab</LI>
<LI>Check under Scilab that the current directory is the lpsolve directory.
Use the Scilab pwd command to show the current directory.
With the chdir command, you can change the current directory.
This current directory must be lp_solve_5.5/extra/scilab/lpsolve
example: chdir('d:/lp_solve/lp_solve_5.5/extra/scilab/lpsolve')</LI>
<LI>To compile and build sclpsolve, enter the following command in Scilab:
   --&gt;exec builder.sce
This should be done once to build the sclpsolve driver and to produce
the file loader.sce.</LI></OL>
Load the sclpsolve driver in the Scilab memory space:
-----------------------------------------------------<OL><LI>Under Windows, make sure that the lpsolve55.dll file is somewhere in the path
Under Unix/Linux, make sure that the liblpsolve55.so shared library is in /usr/lib
or /lib so that Unix can find it.
They are in archives lp_solve_5.5.2.14_dev.zip/lp_solve_5.5.2.14_dev.tar.gz and were
installed in the lp_solve_5.5 directory of step 1 of the previous procedure.</LI>
<LI>It is required that the sclpsolve driver is first build.
That must be done only once. So if you haven't taken the steps yet
to build the sclpsolve driver, then do this first as described previously in
'Compile and build sclpsolve'</LI>
<LI>Start Scilab</LI>
<LI>Check under Scilab that the current directory is the lpsolve directory.
Use the Scilab pwd command to show the current directory.
With the chdir command, you can change the current directory.
This current directory must be lp_solve_5.5/extra/scilab/lpsolve
example: chdir('/lp_solve/lp_solve_5.5/extra/scilab/lpsolve')</LI>
<LI>Enter the following command in Scilab:
   --&gt;exec loader.sce</LI></OL></pre>

<a name="Installation"></a>
<h3>Installation</h3>

<p>To make this possible, a driver program is needed: sclpsolve (sclpsolve.dll under Windows, sclpsolve.a under Unix/Linux).
This driver must be put in a directory known to Scilab and Scilab can call the sclpsolve solver.</p>

<p>This driver calls lpsolve via the lpsolve shared library (lpsolve55.dll under Windows
and liblpsolve55.so under Unix/Linux) (in archive lp_solve_5.5.2.14_dev.zip/lp_solve_5.5.2.14_dev.tar.gz). This has the advantage that the sclpsolve driver doesn't have to
be recompiled when an update of lpsolve is provided.
For Windows, the lpsolve55.dll file must be somewhere in the path.
For Unix, the lpsolve shared library (liblpsolve55.so) must be in the /usr/lib or /lib directory.</p>

<p>So note the difference between the Scilab lpsolve driver that is called sclpsolve and the lpsolve library that implements the
API that is called lpsolve55.</p>

<p>There are also some Scilab script files (*.sce, *.sci) as a quick start.</p>

<p>The first thing that must be done, each time Scilab is restarted and you want to use lpsolve is load
the sclpsolve driver into the Scilab workspace. This can be done via the script loader.sce.
The following command must be used to load the driver:</p>

<pre>exec loader.sce</pre>

<p>It is assumed here that the current directory is the Scilab lpsolve directory (lp_solve_5.5/extra/scilab/lpsolve),
but this is not a requirement. You can also provide the full path to the script files. The current directory can be
shown via the pwd command in Scilab:</p>

<pre>pwd</pre>

<p>That is basically all you need to do. From now on, you can use the library. This until Scilab is restarted.
Then this command must be given again to reload the library.</p>

<p>To make things easier, you can edit the file scilab.star with your favourite editor (or notepad/vi) in the Scilab directory
and add above line at the end of this file.
That will automatically load the lpsolve driver in memory when Scilab is started.
So it will appear as if the sclpsolve command is then always available.</p>

<p>If you get an error similar to below, then probably the lpsolve library can not be found:</p>

<pre>link failed for dll c:\lp_solve\lp_solve_5.5\extra\scilab\lpsolve\libs\sclpsolve.dll
addinter(liblpmex,'lpmex_gateway','sclpsolve')
                                               !--error   236
link: the shared archive was not loaded
</pre>

<p>Under Windows, the lpsolve55.dll file must be in one of the directories specified by the PATH environment variable.
This path can be seen in Scilab via the command getenv("PATH"). It is common to place dlls in the WINDOWS\system32 folder.</p>

<p>Under Unix/Linux, the liblpsolve55.so file must be in the directory /usr/lib or /lib.</p>

<p>To test if everything is installed correctly, enter sclpsolve() in the Scilab command window.
If it gives the following, then everything is ok:</p>

<pre>sclpsolve  scilab Interface version 5.5.0.6
using lpsolve version 5.5.2.14

Usage: [ret1, ret2, ...] = sclpsolve('functionname', arg1, arg2, ...)
</pre>

<p>All this is developed and tested with Scilab versions 2.7 and 3.0 both under Windows and Linux (RedHat).</p>

<a name="Solve_an_lp_model_from_Scilab_via_sclpsolve"></a>
<h3>Solve an lp model from Scilab via sclpsolve</h3>

<p>In the following text, --&gt; before the Scilab commands is the Scilab prompt.
Only the text after --&gt; must be entered.
</p>

<p>To call an lpsolve function, the following syntax must be used:</p>

<pre>--&gt;[ret1, ret2, ...] = sclpsolve('functionname', arg1, arg2, ...)</pre>

<p>The return values are optional and depend on the function called. functionname must always be enclosed between (single or double)
quotes to make it alphanumerical and it is case sensitive. The number and type of arguments depend on the function called.
Some functions even have a variable number of arguments and a different behaviour occurs depending on the type of the argument.
functionname can be (almost) any of the lpsolve API routines (see <a href="lp_solveAPIreference.htm">lp_solve API reference</a>)
plus some extra Scilab specific functions.
Most of the lpsolve API routines use or return an lprec structure. To make things more robust in Scilab, this structure
is replaced by a handle or the model name. The lprec structures are maintained internally by the lpsolve driver.
The handle is an incrementing number starting from 0.
Starting from driver version 5.5.0.2, it is also possible to use the model name instead of the handle.
This can of course only be done if a name is given to the model. This is done via lpsolve routine
<a href="#set_lp_name">set_lp_name</a> or by specifying the model name in routine <a href="#read_lp">read_lp</a>.
See <a href="#Using_model_name_instead_of_handle">Using model name instead of handle</a>.
</p>

<p>Almost all callable functions can be found in the <a href="lp_solveAPIreference.htm">lp_solve API reference</a>.
Some are exactly as described in the reference guide, others have a slightly different syntax to make maximum
use of the Scilab functionality. For example make_lp is used identical as described. But get_variables is slightly
different. In the API reference, this function has two arguments. The first the lp handle and the second the
resulting variables and this array must already be dimensioned. When lpsolve is used from Scilab, nothing must
be dimensioned in advance. The sclpsolve driver takes care of dimensioning all return variables and they are
always returned as return value of the call to sclpsolve. Never as argument to the routine. This can be a single
value as for get_objective (although Scilab stores this in a 1x1 matrix) or a matrix or vector as in get_variables.
In this case, get_variables returns a 4x1 matrix (vector) with the result of the 4 variables of the lp model.
</p>

<p>Note that you can get an overview of the available functionnames and their arguments by entering the following in Scilab:</p>

<pre>--&gt;help sclpsolve</pre>

<a name="An_example"></a>
<h3>An example</h3>

<p>(Note that you can execute this example by entering command per command as shown below or by just entering exec example1.sce.
This will execute example1.sce.)</p>

<pre>--&gt;lp=sclpsolve('make_lp', 0, 4);
--&gt;sclpsolve('set_verbose', lp, 3);
--&gt;sclpsolve('set_obj_fn', lp, [1, 3, 6.24, 0.1]);
--&gt;sclpsolve('add_constraint', lp, [0, 78.26, 0, 2.9], 2, 92.3);
--&gt;sclpsolve('add_constraint', lp, [0.24, 0, 11.31, 0], 1, 14.8);
--&gt;sclpsolve('add_constraint', lp, [12.68, 0, 0.08, 0.9], 2, 4);
--&gt;sclpsolve('set_lowbo', lp, 1, 28.6);
--&gt;sclpsolve('set_lowbo', lp, 4, 18);
--&gt;sclpsolve('set_upbo', lp, 4, 48.98);
--&gt;sclpsolve('set_col_name', lp, 1, 'COLONE');
--&gt;sclpsolve('set_col_name', lp, 2, 'COLTWO');
--&gt;sclpsolve('set_col_name', lp, 3, 'COLTHREE');
--&gt;sclpsolve('set_col_name', lp, 4, 'COLFOUR');
--&gt;sclpsolve('set_row_name', lp, 1, 'THISROW');
--&gt;sclpsolve('set_row_name', lp, 2, 'THATROW');
--&gt;sclpsolve('set_row_name', lp, 3, 'LASTROW');
--&gt;sclpsolve('write_lp', lp, 'a.lp');
--&gt;sclpsolve('get_mat', lp, 1, 2)
 ans  =

    78.26

--&gt;sclpsolve('solve', lp)
 ans  =

     0.

--&gt;sclpsolve('get_objective', lp)
 ans  =

   31.782759

--&gt;sclpsolve('get_variables', lp)
 ans  =

!   28.6      !
!   0.        !
!   0.        !
!   31.827586 !

--&gt;sclpsolve('get_constraints', lp)
 ans  =

!   92.3      !
!   6.864     !
!   391.29283 !
</pre>

<p>Note that there are some commands that return an answer. To see the answer, the command was not terminated with
a semicolon (;). If the semicolon is put at the end of a command, the answer is not shown. However it is also possible
to write the answer in a variable. For example:
</p>

<pre>--&gt;obj=sclpsolve('get_objective', lp)
 obj  =

    31.782759
</pre>

<p>Or without echoing on screen:</p>

<pre>--&gt;obj=sclpsolve('get_objective', lp);</pre>

<p>The last command will only write the result in variable obj without showing anything on screen.
get_variables and get_constraints return a vector with the result. This can also be put in a variable:</p>

<pre>--&gt;x=sclpsolve('get_variables', lp);

--&gt;b=sclpsolve('get_constraints', lp);
</pre>

<p>It is always possible to show the contents of a variable by just giving it as command:</p>

<pre>--&gt;x

 x  =
!   28.6      !
!   0.        !
!   0.        !
!   31.827586 !
</pre>

<p>Don't forget to free the handle and its associated memory when you are done:</p>

<pre>--&gt;sclpsolve('delete_lp', lp);</pre>

<a name="Using_model_name_instead_of_handle"></a>
<h3>Using model name instead of handle</h3>
From driver version 5.5.0.2, it is possible to use the model name instead of the handle. From the moment the model
has a name, you can use this name instead of the handle. This is best shown by an example. Above example would look
like this:

<pre>--&gt;lp=sclpsolve('make_lp', 0, 4);
--&gt;sclpsolve('set_lp_name', lp, 'mymodel');
--&gt;sclpsolve('set_verbose', 'mymodel', 3);
--&gt;sclpsolve('set_obj_fn', 'mymodel', [1, 3, 6.24, 0.1]);
--&gt;sclpsolve('add_constraint', 'mymodel', [0, 78.26, 0, 2.9], 2, 92.3);
--&gt;sclpsolve('add_constraint', 'mymodel', [0.24, 0, 11.31, 0], 1, 14.8);
--&gt;sclpsolve('add_constraint', 'mymodel', [12.68, 0, 0.08, 0.9], 2, 4);
--&gt;sclpsolve('set_lowbo', 'mymodel', 1, 28.6);
--&gt;sclpsolve('set_lowbo', 'mymodel', 4, 18);
--&gt;sclpsolve('set_upbo', 'mymodel', 4, 48.98);
--&gt;sclpsolve('set_col_name', 'mymodel', 1, 'COLONE');
--&gt;sclpsolve('set_col_name', 'mymodel', 2, 'COLTWO');
--&gt;sclpsolve('set_col_name', 'mymodel', 3, 'COLTHREE');
--&gt;sclpsolve('set_col_name', 'mymodel', 4, 'COLFOUR');
--&gt;sclpsolve('set_row_name', 'mymodel', 1, 'THISROW');
--&gt;sclpsolve('set_row_name', 'mymodel', 2, 'THATROW');
--&gt;sclpsolve('set_row_name', 'mymodel', 3, 'LASTROW');
--&gt;sclpsolve('write_lp', 'mymodel', 'a.lp');
--&gt;sclpsolve('get_mat', 'mymodel', 1, 2)
 ans  =

    78.26

--&gt;sclpsolve('solve', 'mymodel')
 ans  =

     0.

--&gt;sclpsolve('get_objective', 'mymodel')
 ans  =

   31.782759

--&gt;sclpsolve('get_variables', 'mymodel')
 ans  =

!   28.6      !
!   0.        !
!   0.        !
!   31.827586 !

--&gt;sclpsolve('get_constraints', 'mymodel')
 ans  =

!   92.3      !
!   6.864     !
!   391.29283 !
</pre>

<p>So everywhere a handle is needed, you can also use the model name. You can even mix the two methods.
There is also a specific Scilab routine to get the handle from the model name: <a href="#get_handle">get_handle</a>.<br>
For example:</p>

<pre>--&gt;sclpsolve('get_handle', 'mymodel')
0
</pre>

<p>Don't forget to free the handle and its associated memory when you are done:</p>

<pre>--&gt;sclpsolve('delete_lp', 'mymodel');</pre>

<p>In the next part of this documentation, the handle is used. But if you name the model, the name could thus also be used.</p>

<a name="Matrices"></a>
<h3>Matrices</h3>
In Scilab, all numerical data is stored in matrices; even a scalar variable. Scilab also supports complex numbers
(a + b * %i with %i=SQRT(-1)). sclpsolve can only work with real numbers.
Scilab also supports sparse matrices. Sparse matrices are matrices where only the non-zero elements are provided
and stored. This results in both less storage and faster calculation if there are a sufficient number of zero values
in the matrix and there usually are. The sclpsolve driver supports both dense and sparse matrices and their use
is totally transparent to the user. Everywhere a matrix can be provided, it can be dense or sparse. However, Scilab
requires for interface programs that sparse matrixes are converted to MATLAB sparse matrices via the function mtlb_sparse(mat).
In the above example all matrices were dense. For example:

<pre>--&gt;sclpsolve('add_constraint', lp, [0.24, 0, 11.31, 0], 1, 14.8);</pre>

<p>In sparse matrix notation, this can be written:</p>

<pre>--&gt;sclpsolve('add_constraint', lp, mtlb_sparse(sparse([0.24, 0, 11.31, 0])), 1, 14.8);</pre>

<p>Most of the time, variables are used to provide the data:</p>

<pre>--&gt;sclpsolve('add_constraint', lp, a1, 1, 14.8);</pre>

<p>Where a1 is a dense matrix variable. A sparse matrix is then provided as follows:</p>

<pre>--&gt;sclpsolve('add_constraint', lp, mtlb_sparse(a1), 1, 14.8);</pre>

<p>The sclpsolve driver sees all provided matrices as sparse matrices. sclpsolve also uses sparse matrices
internally and data can be provided sparse via the ex routines. For example add_constraintex. The sclpsolve
driver always uses the ex routines to provide the data to lpsolve. Even if you call from Scilab the routine
names that would require a dense matrix (for example add_constraint), the sclpsolve driver will always call the
sparse version of the routine (for example add_constraintex). This results in the most performing behaviour.
Note that if a dense matrix is provided, the dimension must exactly match the dimension that is expected by
sclpsolve. Matrices with too few or too much elements gives an 'invalid vector.' error. Sparse matrices can off
course provide less elements (the non provided elements are seen as zero). However if too many elements are
provided or an element with a too large index, again an 'invalid vector.' error is raised.</p>

<p>Most of the time, sclpsolve needs vectors (rows or columns).
In all situations, it doesn't matter if the vectors are row or column vectors. The driver accepts them both.
For example:</p>

<pre>--&gt;sclpsolve('add_constraint', lp, [0.24; 0; 11.31; 0], 1, 14.8);</pre>

<p>Which is a column vector, but it is also accepted.</p>

<p>An important final note. Several lp_solve API routines accept a vector where the first element (element 0) is not used.
Other lp_solve API calls do use the first element. In the Scilab interface, there is never an unused element in the matrices.
So if the lp_solve API specifies that the first element is not used, then this element is not in the Scilab matrix.</p>

<a name="Sets"></a>
<h3>Sets</h3>

<p>All numerical data is stored in matrices. Alphanumerical data, however, is more difficult to store in matrices.
Matrices require that each element has the same size (length) and that is difficult and unpractical for alphanumerical
data. In a limited number of lpsolve routines, alphanumerical data is required or returned and in some also multiple
elements. An example is set_col_name. For this, Scilab sets are used.<br>
To specify a set of alphanumerical elements, the following notation is used: cellstr([element1; element1; ...]).<br>
Note the cellstr() function and the ; between each element.<br>
An alternative is the Scilab makecell() function. For example makecell([1,3], element1, element2, element3).<br>
Another alternative is the Scilab cell() function. For example x=cell(1,3); x(1).entries=element1; x(2).entries=element2; x(3).entries=element3
</p>

<p>Don't forget that a set of strings must be provided. Don't make the mistake of using the syntax {element1, element2, ...}
because then the following error occurs:</p>

<pre>                                                                           !--error  9999
Invalid string matrix (at most one column!)
                                                                           !--error   999
SIGSTP: aborting current computation
</pre>

<p>And also not {element1; element2; ...} because then the following error is given:</p>

<pre>                                                                           !--error  9999
invalid vector
                                                                           !--error   999
SIGSTP: aborting current computation
</pre>

<p>This is not an error generated by the sclpsolve driver, but from the Scilab parser because both are not sets.</p>

<a name="Maximum_usage_of_matrices_sets_with_sclpsolve"></a>
<h3>Maximum usage of matrices/sets with sclpsolve</h3>

<p>Because Scilab is all about matrices, all lpsolve API routines that need a column or row number to get/set information for that
column/row are extended in the sclpsolve Scilab driver to also work with matrices. For example set_int in the API can
only set the integer status for one column. If the status for several integer variables must be set, then set_int
must be called multiple times. The sclpsolve Scilab driver however also allows specifying a vector to set the integer
status of all variables at once. The API call is: return = sclpsolve('set_int', lp, column, must_be_int). The
matrix version of this call is: return = sclpsolve('set_int', lp, [must_be_int]).
The API call to return the integer status of a variable is: return = sclpsolve('is_int', lp, column). The
matrix version of this call is: [is_int] = sclpsolve('is_int', lp)<br>
Also note the get_mat and set_mat routines. In Scilab these are extended to return/set the complete constraint matrix.
See following example.
</p>

<p>Above example can thus also be done as follows:<br>
(Note that you can execute this example by entering command per command as shown below or by just entering exec example2.sce.
This will execute example2.sce.)</p>

<pre>--&gt;lp=sclpsolve('make_lp', 0, 4);
--&gt;sclpsolve('set_verbose', lp, 3);
--&gt;sclpsolve('set_obj_fn', lp, [1, 3, 6.24, 0.1]);
--&gt;sclpsolve('add_constraint', lp, [0, 78.26, 0, 2.9], 2, 92.3);
--&gt;sclpsolve('add_constraint', lp, [0.24, 0, 11.31, 0], 1, 14.8);
--&gt;sclpsolve('add_constraint', lp, [12.68, 0, 0.08, 0.9], 2, 4);
--&gt;sclpsolve('set_lowbo', lp, [28.6, 0, 0, 18]);
--&gt;sclpsolve('set_upbo', lp, [%inf, %inf, %inf, 48.98]);
--&gt;sclpsolve('set_col_name', lp, cellstr(['COLONE';'COLTWO';'COLTHREE';'COLFOUR']));
--&gt;sclpsolve('set_row_name', lp, cellstr(['THISROW';'THATROW';'LASTROW']));
--&gt;sclpsolve('write_lp', lp, 'a.lp');
--&gt;sclpsolve('get_mat', lp)
 ans  =

!   0.       78.26    0.       2.9 !
!    .24     0.       11.31    0.  !
!   12.68    0.        .08      .9 !

--&gt;sclpsolve('solve', lp)
 ans  =

    0.

--&gt;sclpsolve('get_objective', lp)
 ans  =

    31.782759

--&gt;sclpsolve('get_variables', lp)
 ans  =

!   28.6      !
!   0.        !
!   0.        !
!   31.827586 !

--&gt;sclpsolve('get_constraints', lp)
 ans  =

!   92.3      !
!   6.864     !
!   391.29283 !
</pre>

<p>Note the usage of %inf in set_upbo. This stands for 'infinity'. Meaning an infinite upper bound.
It is also possible to use -%inf to express minus infinity. This can for example be used to create a free variable.</p>

<p>Starting from driver version 5.5.0.3, get_mat can also return the matrix in sparse format. By default
the function returns it in dense format for backwards compatibility. However if a 3rd argument is provided that is
non-zero, the returned matrix is sparse:</p>

<pre>--&gt;sclpsolve('get_mat', lp, 1)
 ans  =

(3,    4) m sparse matrix

(2,    1)         .24
(3,    1)        12.68
(1,    2)        78.26
(2,    3)        11.31
(3,    3)         .08
(1,    4)        2.9
(3,    4)         .9
</pre>

<p>To show the full power of the matrices, let's now do some matrix calculations to check the solution.
It works further on above example:</p>

<pre>--&gt;A=sclpsolve('get_mat', lp);

--&gt;X=sclpsolve('get_variables', lp);

--&gt;B = A * X
 B  =

!   92.3      !
!   6.864     !
!   391.29283 !
</pre>

<p>So what we have done here is calculate the values of the constraints (RHS) by multiplying the constraint matrix
with the solution vector. Now take a look at the values of the constraints that lpsolve has found:</p>

<pre>--&gt;sclpsolve('get_constraints', lp)
 ans  =

!   92.3      !
!   6.864     !
!   391.29283 !
</pre>

<p>Exactly the same as the calculated B vector, as expected.</p>

<p>Also the value of the objective can be calculated in a same way:</p>

<pre>--&gt;C=sclpsolve('get_obj_fn', lp);

--&gt;X=sclpsolve('get_variables', lp);

 obj  =

    31.782759
</pre>

<p>So what we have done here is calculate the value of the objective by multiplying the objective vector
with the solution vector. Now take a look at the value of the objective that lpsolve has found:</p>

<pre>--&gt;sclpsolve('get_objective', lp)
 ans  =

   31.7828
</pre>

<p>Again exactly the same as the calculated obj value, as expected.</p>

<a name="Using_string_constants"></a>
<h3>Using string constants</h3>
From driver version 5.5.2.14 on, it is possible to use string constants
everywhere an lp_solve constant is needed or returned. This is best shown by an example.
In the above code we had:

<pre>--&gt;lp=sclpsolve('make_lp', 0, 4);
--&gt;sclpsolve('set_verbose', lp, 3);
--&gt;sclpsolve('add_constraint', lp, [0, 78.26, 0, 2.9], 2, 92.3);
--&gt;sclpsolve('add_constraint', lp, [0.24, 0, 11.31, 0], 1, 14.8);
--&gt;sclpsolve('add_constraint', lp, [12.68, 0, 0.08, 0.9], 2, 4);</pre>

<p>Note the 3rd parameter on set_verbose and the 4th on add_constraint. These are
    lp_solve constants. One could define all the possible constants in Scilab and
    then use them in the calls, but that has several disadvantages. First there
    stays the possibility to provide a constant that is not intended for that
    particular call. Another issue is that calls that return a constant are still
    returning it numerical.</p>
<p>Both issues can now be handled by string constants. The above code can be done as
    following with string constants:</p>

<pre>--&gt;lp=sclpsolve('make_lp', 0, 4);
--&gt;sclpsolve('set_verbose', lp, &#39;IMPORTANT&#39;);
--&gt;sclpsolve('add_constraint', lp, [0, 78.26, 0, 2.9], &#39;GE&#39;, 92.3);
--&gt;sclpsolve('add_constraint', lp, [0.24, 0, 11.31, 0], &#39;LE&#39;, 14.8);
--&gt;sclpsolve('add_constraint', lp, [12.68, 0, 0.08, 0.9], &#39;GE&#39;, 4);</pre>

<p>This is not only more readable, there is much lesser chance that mistakes are
    being made. The calling routine knows which constants are possible and only
    allows these. So unknown constants or constants that are intended for other
    calls are not accepted. For example:</p>

<pre>--&gt;sclpsolve('set_verbose', lp, &#39;blabla&#39;);

BLABLA: Unknown.

--&gt;sclpsolve('set_verbose', lp, &#39;GE&#39;);

GE: Not allowed here.</pre>

<p>Note the difference between the two error messages. The first says that the
    constant is not known, the second that the constant cannot be used at that
    place.</p>
<p>Constants are case insensitive. Internally they are always translated to upper
    case. Also when returned they will always be in upper case.</p>
<p>The constant names are the ones as specified in the documentation of each API
    routine. There are only 3 exceptions, extensions actually. &#39;LE&#39;, &#39;GE&#39; and &#39;EQ&#39; in
    <a href="add_constraint.htm">add_constraint</a> and <a href="is_constr_type.htm">is_constr_type</a>
    can also be &#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;, &#39;=&#39;. When returned however, &#39;GE&#39;, &#39;LE&#39;, &#39;EQ&#39;
    will be used.</p>

<p>Also in the matrix version of calls, string constants are possible (hm). For example:</p>

<pre>--&gt;sclpsolve(&#39;set_constr_type&#39;, lp, cellstr([&#39;LE&#39;; &#39;EQ&#39;; &#39;GE&#39;]));</pre>

<p>Some constants can be a combination of multiple constants. For example
    <a href="set_scaling.htm">set_scaling</a>:</p>

<pre>--&gt;sclpsolve(&#39;set_scaling&#39;, lp, 3+128);</pre>

<p>With the string version of constants this can be done as following:</p>

<pre>--&gt;sclpsolve(&#39;set_scaling&#39;, lp, 'SCALE_MEAN|SCALE_INTEGERS');</pre>

<p>| is the OR operator used to combine multiple constants. There may optinally be
    spaces before and after the |.</p>
<p>Not all OR combinations are legal. For example in set_scaling, a choice must be
    made between SCALE_EXTREME, SCALE_RANGE, SCALE_MEAN, SCALE_GEOMETRIC or
    SCALE_CURTISREID. They may not be combined with each other. This is also tested:</p>

<pre>--&gt;sclpsolve(&#39;set_scaling&#39;, lp, 'SCALE_MEAN|SCALE_RANGE');

SCALE_RANGE cannot be combined with SCALE_MEAN</pre>

<p>Everywhere constants must be provided, numeric or string values may be provided.
    The routine automatically interpretes them. </p>
<p>Returning constants is a different
    story. The user must let lp_solve know how to return it. Numerical or as string.
    The default is numerical:</p>

<pre>--&gt;sclpsolve(&#39;get_scaling&#39;, lp)
 ans  =

    131.</pre>

<p>To let lp_solve return a constant as string, a call to a new function must be
    made: return_constants</p>

<pre>--&gt;sclpsolve(&#39;return_constants&#39;, 1);</pre>

<p>From now on, all returned constants are returned as string:</p>

<pre>--&gt;sclpsolve(&#39;get_scaling&#39;, lp)
 ans  =

 SCALE_MEAN|SCALE_INTEGERS</pre>

<p>Also when an array of constants is returned, they are returned as string when
    return_constants is set:</p>

<pre>--&gt;sclpsolve('get_constr_type', lp)
 ans  =


!"LE"  "EQ"  "GE"  !</pre>

<p>This for all routines until return_constants is again called with 0:</p>

<pre>--&gt;sclpsolve(&#39;return_constants&#39;, 0);</pre>

<p>The (new) current setting of return_constants is always returned by the call.
    Even when set:</p>

<pre>--&gt;sclpsolve(&#39;return_constants&#39;, 1)
 ans  =

    1.</pre>

<p>To get the value without setting it, don&#39;t provide the second argument:</p>

<pre>--&gt;sclpsolve(&#39;return_constants&#39;)
 ans  =

    1.</pre>

<p>In the next part of this documentation, return_constants is the default, 0, so all
    constants are returned numerical and provided constants are also numerical. This
    to keep the documentation as compatible as possible with older versions. But
    don&#39;t let you hold that back to use string constants in your code.</p>

<a name="Script_files"></a>
<h3>Script files</h3>

<p>Scilab can execute a sequence of statements stored in diskfiles. Scilab has two kinds of these.
The first kinds are ASCII files where Scilab commands are written in the same way as in the command window.
These files normally have the extension .sce. These script files must be executed via the exec command. For example:</p>

<pre>exec example1.sce</pre>

<p>The second kinds are binary files. However the user enters the commands first in an ASCII file (normally with extension .sci)
and then these are translated to binary files via the Scilab genlib command. The .sci files also may only contain Scilab commands.
There are two advantages of using these. The first is that you don't have to use the exec command or provide the extension to execute them.
So it is as if you execute a regular Scilab command. The second advantage is that they are somewhat faster.
</p>

<p>The lpsolve distribution contains some sample .sce files that must be executed via exec and also some .sci
high-level routines that can be executed without exec. They are already precompiled.</p>

<h4>example1.sce</h4>

<p>Contains the commands as shown in the first example of this article. Execute via exec example1.sce</p>

<h4>example2.sce</h4>

<p>Contains the commands as shown in the second example of this article. Execute via exec example2.sce</p>

<h4>example3.sce</h4>

<p>Contains the commands of a practical example. See further in this article.</p>

<h4>example4.sce</h4>

<p>Contains the commands of a practical example. See further in this article.</p>

<h4>example5.sce</h4>

<p>Contains the commands of a practical example. See further in this article.</p>

<h4>example6.sce</h4>

<p>Contains the commands of a practical example. See further in this article.</p>

<h4>lp_solve.sci</h4>

<p>This script uses the API to create a higher-level function called lp_solve.
This function accepts as arguments some matrices and options to create and solve an lp model.
See the beginning of the file or type help lp_solve to see its usage:</p>

<pre> LP_SOLVE  Solves mixed integer linear programming problems.

   SYNOPSIS: [obj,x,duals] = lp_solve(f,a,b,e,vlb,vub,xint,scalemode,keep)

      solves the MILP problem

              max v = f'*x
                a*x &lt;&gt; b
                  vlb &lt;= x &lt;= vub
                  x(int) are integer

   ARGUMENTS: The first four arguments are required:

            f: n vector of coefficients for a linear objective function.
            a: m by n matrix representing linear constraints.
            b: m vector of right sides for the inequality constraints.
            e: m vector that determines the sense of the inequalities:
                      e(i) = -1  ==&gt; Less Than
                      e(i) =  0  ==&gt; Equals
                      e(i) =  1  ==&gt; Greater Than
          vlb: n vector of lower bounds. If empty or omitted,
               then the lower bounds are set to zero.
          vub: n vector of upper bounds. May be omitted or empty.
         xint: vector of integer variables. May be omitted or empty.
    scalemode: scale flag. Off when 0 or omitted.
         keep: Flag for keeping the lp problem after it's been solved.
               If omitted, the lp will be deleted when solved.

   OUTPUT: A nonempty output is returned if a solution is found:

          obj: Optimal value of the objective function.
            x: Optimal value of the decision variables.
        duals: solution of the dual problem.
</pre>

<p>Example of usage. To create and solve following lp-model:</p>

<pre>max: -x1 + 2 x2;
C1: 2x1 + x2 &lt; 5;
-4 x1 + 4 x2 &lt;5;

int x2,x1;
</pre>

<p>The following command can be used:</p>

<pre>--&gt;[obj, x]=lp_solve([-1, 2], [2, 1; -4, 4], [5, 5], [-1, -1], [], [], [1, 2])
 x  =

!   1. !
!   2. !
 obj  =

    3.
</pre>

<p>Note that you can also provide sparse matrices to this function without having to use mtlb_sparse.
The script is taking care of this.</p>

<h4>lp_maker.sci</h4>

<p>This script is analog to the lp_solve script and also uses the API to create a higher-level function called lp_maker.
This function accepts as arguments some matrices and options to create an lp model. Note that this scripts only
creates a model and returns a handle.
See the beginning of the file or type help lp_maker or just lp_maker to see its usage:</p>

<pre>--&gt;help lp_maker

 LP_MAKER  Makes mixed integer linear programming problems.

   SYNOPSIS: lp_handle = lp_maker(f,a,b,e,vlb,vub,xint,scalemode,setminim)
      make the MILP problem
        max v = f'*x
          a*x &lt;&gt; b
            x &gt;= vlb &gt;= 0
            x &lt;= vub
            x(int) are integer

   ARGUMENTS: The first four arguments are required:
            f: n vector of coefficients for a linear objective function.
            a: m by n matrix representing linear constraints.
            b: m vector of right sides for the inequality constraints.
            e: m vector that determines the sense of the inequalities:
                      e(i) &lt; 0  ==&gt; Less Than
                      e(i) = 0  ==&gt; Equals
                      e(i) &gt; 0  ==&gt; Greater Than
          vlb: n vector of non-negative lower bounds. If empty or omitted,
               then the lower bounds are set to zero.
          vub: n vector of upper bounds. May be omitted or empty.
         xint: vector of integer variables. May be omitted or empty.
    scalemode: scale flag. Off when 0 or omitted.
     setminim: Set maximum lp when this flag equals 0 or omitted.

   OUTPUT: lp_handle is an integer handle to the lp created.
</pre>

<p>Example of usage. To create following lp-model:</p>

<pre>max: -x1 + 2 x2;
C1: 2x1 + x2 &lt; 5;
-4 x1 + 4 x2 &lt;5;

int x2,x1;
</pre>

<p>The following command can be used:</p>

<pre>--&gt;lp=lp_maker([-1, 2], [2, 1; -4, 4], [5, 5], [-1, -1], [], [], [1, 2])
 lp  =

    0.
</pre>

<p>To solve the model and get the solution:</p>

<pre>--&gt;sclpsolve('solve', lp)
 ans  =

    0.

--&gt;sclpsolve('get_objective', lp)
 ans  =

    3.

--&gt;sclpsolve('get_variables', lp)
 ans  =

!   1. !
!   2. !
</pre>

<p>Don't forget to free the handle and its associated memory when you are done:</p>

<pre>--&gt;sclpsolve('delete_lp', lp);</pre>

<p>Note that you can also provide sparse matrices to this function without having to use mtlb_sparse.
The script is taking care of this.</p>

<h4>lpdemo.sce</h4>

<p>Contains several examples to build and solve lp models. Execute via exec lpdemo.sce</p>

<h4>ex.sce</h4>

<p>Contains several examples to build and solve lp models.
Also solves the lp_examples from the lp_solve distribution. Execute via exec ex.sce</p>

<a name="A_practical_example"></a>
<h3>A practical example</h3>

<p>We shall illustrate the method of linear programming by means of a simple example,
giving a combination graphical/numerical solution, and then solve both a slightly as well as a substantially
more complicated problem.</p>

<p>Suppose a farmer has 75 acres on which to plant two crops: wheat and barley.
To produce these crops, it costs the farmer (for seed, fertilizer, etc.) $120 per acre for the
wheat and  $210 per acre for the barley. The farmer has $15000 available for expenses.
But after the harvest, the farmer must store the crops while awaiting favourable market conditions.
The farmer has storage space for 4000 bushels. Each acre yields an average of 110 bushels of wheat
or 30 bushels of barley.  If the net profit per bushel of wheat (after all expenses have been subtracted)
is $1.30 and for barley is $2.00, how should the farmer plant the 75 acres to maximize profit?</p>

<p>We begin by formulating the problem mathematically. 
First we express the objective, that is the profit, and the constraints
algebraically, then we graph them, and lastly we arrive at the solution
by graphical inspection and a minor arithmetic calculation.</p>

<p>Let x denote the number of acres allotted to wheat and y the number of acres allotted to barley.
Then the expression to be maximized, that is the profit, is clearly</p>

<p align="center">P = (110)(1.30)x + (30)(2.00)y = 143x + 60y.</p>

<p>There are three constraint inequalities, specified by the limits on expenses, storage and acreage.
They are respectively:</p>

<p align="center">
120x + 210y &lt;= 15000<br>
110x + 30y &lt;= 4000<br>
x + y &lt;= 75
</p>

<p>Strictly speaking there are two more constraint inequalities forced by the fact that the farmer cannot plant
a negative number of acres, namely:</p>

<p align="center">x &gt;= 0, y &gt;= 0.</p>

<p>Next we graph the regions specified by the constraints. The last two say that we only need to consider
the first quadrant in the x-y plane. Here's a graph delineating the triangular region in the first quadrant determined
by the first inequality.</p>

<pre>
--&gt;clear
--&gt;X = 0.1:0.1:125;
--&gt;Y1 = (15000. - 120*X)/210;
--&gt;plot2d3(X, Y1)
</pre>

<p><IMG alt="Source" src="Scilab1.jpg" border="0"></p>

<p>Now let's put in the other two constraint inequalities.</p>

<pre>
--&gt;clear
--&gt;X = 0.1:0.05:38;
--&gt;Y1 = (15000. - 120*X)/210;
--&gt;Y2 = max((4000 - 110.*X)./30, 0);
--&gt;Y3 = max(75 - X, 0.);
--&gt;Ytop = min(min(Y1, Y2), Y3);
--&gt;plot2d3(X, Ytop)
--&gt;xtitle("Solution space")
</pre>

<p><IMG alt="Source" src="Scilab2.jpg" border="0"></p>

<p>The black area is the solution space that holds valid solutions. This means that any point in this area fulfils the
constraints.
</p>

<p>Now let's superimpose on top of this picture the objective function P.</p>

<pre>
--&gt;X = 15:20:35;
--&gt;plot2d(X, (6315.63 - 143.0 * X) / 60.0)
--&gt;xtitle("Solution space and objective")
</pre>

<p><IMG alt="Source" src="Scilab3.jpg" border="0"></p>

<p>The line gives a picture of the objective function.
All solutions that intersect with the black area are valid solutions, meaning that this result also fulfils
the set constraints. The more the line goes to the right, the higher the objective value is. The optimal solution
or best objective is a line that is still in the black area, but with an as large as possible value (as shown here).
</p>

<p>It seems apparent that the maximum value of P will occur on the level curve (that is, level
line) that passes through the vertex of the polygon that lies near (22,53).<br>
It is the intersection of x + y = 75 and 110*x + 30*y = 4000<br>
This is a corner point of the diagram. This is not a coincidence. The simplex algorithm, which is used
by lp_solve, starts from a theorem that the optimal solution is such a corner point.<br>
In fact we can compute the result:</p>

<pre>
--&gt;x = [1, 1; 110, 30] \ [75; 4000]
 x  =

!   21.875 !
!   53.125 !
</pre>

<p>The acreage that results in the maximum profit is 21.875 for wheat and 53.125 for barley.
In that case the profit is:</p>

<pre>
--&gt;P = [143, 60] * x
 P  =

    6315.625
</pre>

<p>That is, $6315.625.</p>

<p>Note that these command are in script example3.sce</p>

<p>Now, lp_solve comes into the picture to solve this linear programming problem more generally.
After that we will use it to solve two more complicated problems involving more variables
and constraints.</p>

<p>For this example, we use the higher-level script lp_maker to build the model and then some lp_solve API calls
to retrieve the solution. Here is again the usage of lp_maker:</p>

<pre>
 LP_MAKER  Makes mixed integer linear programming problems.

   SYNOPSIS: lp_handle = lp_maker(f,a,b,e,vlb,vub,xint,scalemode,setminim)
      make the MILP problem
        max v = f'*x
          a*x &lt;&gt; b
            x &gt;= vlb &gt;= 0
            x &lt;= vub
            x(int) are integer

   ARGUMENTS: The first four arguments are required:
            f: n vector of coefficients for a linear objective function.
            a: m by n matrix representing linear constraints.
            b: m vector of right sides for the inequality constraints.
            e: m vector that determines the sense of the inequalities:
                      e(i) &lt; 0  ==&gt; Less Than
                      e(i) = 0  ==&gt; Equals
                      e(i) &gt; 0  ==&gt; Greater Than
          vlb: n vector of non-negative lower bounds. If empty or omitted,
               then the lower bounds are set to zero.
          vub: n vector of upper bounds. May be omitted or empty.
         xint: vector of integer variables. May be omitted or empty.
    scalemode: scale flag. Off when 0 or omitted.
     setminim: Set maximum lp when this flag equals 0 or omitted.

   OUTPUT: lp_handle is an integer handle to the lp created.
</pre>

<p>Now let's formulate this model with lp_solve:</p>

<pre>
--&gt;f = [143, 60];
--&gt;A = [120, 210; 110, 30; 1, 1];
--&gt;b = [15000, 4000, 75];
--&gt;lp = lp_maker(f, A, b, [-1, -1, -1], [], [], [], 1, 0);
--&gt;solvestat = sclpsolve("solve", lp)
 solvestat  =

    0.

--&gt;sclpsolve("get_objective", lp)
 ans  =

    6315.625

--&gt;sclpsolve("get_variables", lp)
 ans  =

!   21.875 !
!   53.125 !

--&gt;sclpsolve("delete_lp", lp);
</pre>

<p>Note that these command are in script example4.oms</p>

<p>With the higher-level script lp_maker, we provide all data to lp_solve. lp_solve returns a handle (lp) to the
created model. Then the API call 'solve' is used to calculate the optimal solution of the model.
The value of the objective function is retrieved via the API call 'get_objective' and the values of the variables
are retrieved via the API call 'get_variables'. At last, the model is removed from memory via a call to 'delete_lp'.
Don't forget this to free all memory allocated by lp_solve.</p>

<p>The solution is the same answer we obtained before. 
Note that the non-negativity constraints are accounted implicitly because variables are by default non-negative
in lp_solve.</p>

<p>Well, we could have done this problem by hand (as shown in the introduction) because it is very small and it
can be graphically presented.<br>
Now suppose that the farmer is dealing with a third crop, say corn, and that the corresponding data is:</p>

<blockquote>
<table cellSpacing="1" cellPadding="1" border="1" ID="Table1">
<tr><td>cost per acre</td><td>$150.75</td></tr>
<tr><td>yield per acre</td><td>125 bushels</td></tr>
<tr><td>profit per bushel</td><td>$1.56</td></tr>
</table>
</blockquote>

<p>With three variables it is already a lot more difficult to show this model graphically. Adding more variables
makes it even impossible because we can't imagine anymore how to represent this. We only have a practical understanding
of 3 dimentions, but beyound that it is all very theorethical.</p>

<p>If we denote the number of acres allotted to corn by z, then the objective function becomes:</p>

<p align="center">P = (110)(1.30)x + (30)(2.00)y + (125)(1.56) = 143x + 60y + 195z</p>

<p>And the constraint inequalities are:</p>

<p align="center">
120x + 210y + 150.75z &lt;= 15000<br>
110x + 30y + 125z &lt;= 4000<br>
x + y + z &lt;= 75<br>
x &gt;= 0, y &gt;= 0, z &gt;= 0
</p>

<p>The problem is solved with lp_solve as follows:</p>

<pre>
--&gt;f = [143, 60, 195];
--&gt;A = [120, 210, 150.75; 110, 30, 125; 1, 1, 1];
--&gt;b = [15000, 4000, 75];
--&gt;lp = lp_maker(f, A, b, [-1, -1, -1], [], [], [], 1, 0);
--&gt;solvestat = sclpsolve("solve", lp)
 solvestat  =

    0.

--&gt;sclpsolve("get_objective", lp)
 ans  =

    6986.8421

--&gt;sclpsolve("get_variables", lp)
 ans  =

!  0.        !
!  56.578947 !
!  18.421053 !

--&gt;sclpsolve("delete_lp", lp);
</pre>

<p>Note that these command are in script example5.oms</p>

<p>So the farmer should ditch the wheat and plant 56.5789 acres of barley and 18.4211 acres of corn.</p>

<p>There is no practical limit on the number of variables and constraints that Scilab can handle.
Certainly none that the relatively unsophisticated user will encounter. Indeed, in
many true applications of the technique of linear programming, one needs
to deal with many variables and constraints. The solution of such
a problem by hand is not feasible, and software like Scilab is crucial
to success. For example, in the farming problem with which we
have been working, one could have more crops than two or three. Think
agribusiness instead of family farmer. And one could have constraints
that arise from other things beside expenses, storage and acreage limitations. For example:</p>
<ul>
  <li>Availability of seed. This might lead to constraint inequalities like xj &lt; k.</li>
  <li>Personal preferences. Thus the farmer's spouse might have a preference
  for one variety over another and insist on a corresponding planting,
  or something similar with a collection of crops; thus constraint inequalities
  like xi &lt; xj or x1 + x2 &gt; x3.</li>
  <li>Government subsidies. It may take a moment's reflection on the reader's part,
  but this could lead to inequalities like xj &gt; k.</li>
</ul>

<p>Below is a sequence of commands that solves exactly such a problem.
You should be able to recognize the objective expression and the constraints from the data that is entered. 
But as an aid, you might answer the following questions:
</p>

<ul>
  <li>How many crops are under consideration?</li>
  <li>What are the corresponding expenses? How much is available for expenses?</li>
  <li>What are the yields in each case? What is the storage capacity?</li>
  <li>How many acres are available?</li>
  <li>What crops are constrained by seed limitations? To what extent?</li>
  <li>What about preferences?</li>
  <li>What are the minimum acreages for each crop?</li>
</ul>

<pre>
--&gt;f = [110*1.3, 30*2.0, 125*1.56, 75*1.8, 95*.95, 100*2.25, 50*1.35];
--&gt;A = [120,210,150.75,115,186,140,85;110,30,125,75,95,100,50;1,1,1,1,1,1,1;
           1,-1,0,0,0,0,0;0,0,1,0,-2,0,0;0,0,0,-1,0,-1,1];
--&gt;b = [55000, 40000, 400, 0, 0, 0];
--&gt;lp = lp_maker(f, A, b, [-1,-1,-1,-1,-1,-1],[10,10,10,10,20,20,20],[100,%inf,50,%inf,%inf,250,%inf],[],1,0);
--&gt;solvestat = sclpsolve("solve", lp)
 solvestat  =

    0.

--&gt;sclpsolve("get_objective", lp)
 ans  =

    75398.043

--&gt;sclpsolve("get_variables", lp)
 ans  =

!   10.       !
!   10.       !
!   40.       !
!   45.652174 !
!   20.       !
!   250.      !
!   20.       !

--&gt;sclpsolve("delete_lp", lp);
</pre>

<p>Note that these command are in script example6.oms</p>

<p>Note that we have used in this formulation the vlb and vub arguments of lp_maker. This to set lower and upper bounds
on variables. This could have been done via extra constraints, but it is more performant to set bounds on variables.
Also note that %inf is used for variables that have no upper limit. This stands for Infinity.
</p>

<p>Note that despite the complexity of the problem, lp_solve solves it almost instantaneously. It seems the
farmer should bet the farm on crop number 6. We strongly suggest
you alter the expense and/or the storage limit in the problem and see
what effect that has on the answer.</p>

<a name="Another,_more_theoretical,_example"></a>
<h3>Another, more theoretical, example</h3>

<p>Suppose we want to solve the following linear program using Scilab:</p>
<p align="center">
max 4x1 + 2x2 + x3<br>
s. t. 2x1 + x2 &lt;= 1<br>
x1 + 2x3 &lt;= 2<br>
x1 + x2 + x3 = 1<br>
x1 &gt;= 0<br>
x1 &lt;= 1<br>
x2 &gt;= 0<br>
x2 &lt;= 1<br>
x3 &gt;= 0<br>
x3 &lt;= 2<br>
</p>

<p>Convert the LP into Scilab format we get:</p>

<p align="center">
f = [4, 2, 1]<br>
A = [2, 1, 0; 1, 0, 2; 1, 1, 1]<br>
b = [1, 2, 1]
</p>

<p>Note that constraints on single variables are not put in the constraint matrix.
lp_solve can set bounds on individual variables and this is more performant than creating
additional constraints. These bounds are:
</p>

<p align="center">
l = [ 0, 0, 0]<br>
u = [ 1, 1, 2]
</p>

<p>Now lets enter this in Scilab:</p>

<pre>
--&gt;f = [4, 2, 1];
--&gt;A = [2, 1, 0; 1, 0, 2; 1, 1, 1];
--&gt;b = [1, 2, 1];
--&gt;l = [ 0, 0, 0];
--&gt;u = [ 1, 1, 2];
</pre>

<p>Now solve the linear program using Scilab: Type the commands</p>

<pre>
--&gt;lp = lp_maker(f, A, b, [-1, -1, -1], l, u, [], 1, 0);
--&gt;solvestat = sclpsolve("solve", lp)
 solvestat  =

    0.

--&gt;sclpsolve("get_objective", lp)
 ans  =

    2.5

--&gt;sclpsolve("get_variables", lp)
 ans  =

!   0.5 !
!   0.  !
!   0.5 !

--&gt;sclpsolve("delete_lp", lp)
</pre>

<p>What to do when some of the variables are missing ?<br>
For example, suppose there are no lower bounds on the variables. In this case define l to be the empty set using the Scilab command:
</p>

<pre>
--&gt;l = [];
</pre>

<p>This has the same effect as before, because lp_solve has as default lower bound for variables 0.</p>

<p>But what if you want that variables may also become negative?<br>
Then you can use -%inf as lower bounds:</p>

<pre>
--&gt;l = [-%inf, -%inf, -%inf];
</pre>

<p>Solve this and you get a different result:</p>

<pre>
--&gt;lp = lp_maker(f, A, b, [-1, -1, -1], l, u, [], 1, 0);
--&gt;solvestat = sclpsolve("solve", lp)
 solvestat  =

    0.

--&gt;sclpsolve("get_objective", lp)
 ans  =

    2.6666667

--&gt;sclpsolve("get_variables", lp)
 ans  =

!   0.6666667 !
! - 0.3333333 !
!   0.6666667 !

--&gt;sclpsolve("delete_lp", lp)
</pre>

<a name="Overview_of_API_routines"></a>
<h3>Overview of API routines</h3>

<p>Note that everwhere where lp is used as argument that this can be a handle (lp_handle) or the models name.</p>

<ul>
	<li>
		<a href="add_column.htm">add_column, add_columnex</a>
		<ul>
			<li>return = sclpsolve('add_column', lp,
    [column])

			<li>return = sclpsolve('add_columnex', lp,
    [column])

			<li>Both have the same interface from <a href="add_column.htm">add_column</a> but act as <a href="add_column.htm">add_columnex</a></li>
		</ul>
    <li>
        <a href="add_constraint.htm">add_constraint, add_constraintex</a>
        <ul>
            <li>return = sclpsolve('add_constraint', lp,
    [row], constr_type, rh)
            <li>return = sclpsolve('add_constraintex', lp,
    [row], constr_type, rh)
            <li>Both have the same interface from <a href="add_constraint.htm">add_constraint</a> but act as <a href="add_constraint.htm">add_constraintex</a></li>
        </ul>
    <li>
        <a href="add_SOS.htm">add_SOS</a>
        <ul>
            <li>return = sclpsolve('add_SOS', lp, name,
    sostype, priority, [sosvars], [weights])
            <li>The <i>count</i> argument in the API documentation is not needed in Scilab since the number of elements is derived from the size of the sosvars and weights matrices. These must have the same size.</li>
        </ul>
    <li>
        <a href="column_in_lp.htm">column_in_lp</a>
        <ul>
            <li>return = sclpsolve('column_in_lp', lp,
    [column])
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="copy_lp.htm">copy_lp</a>
        <ul>
            <li>lp_handle = sclpsolve('copy_lp', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="default_basis.htm">default_basis</a>
        <ul>
            <li>sclpsolve('default_basis', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="del_column.htm">del_column</a>
        <ul>
            <li>return = sclpsolve('del_column', lp, column)

            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="del_constraint.htm">del_constraint</a>
        <ul>
            <li>return = sclpsolve('del_constraint', lp,
    del_row)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="delete_lp.htm">delete_lp</a>
        <ul>
            <li>sclpsolve('delete_lp', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="free_lp.htm">free_lp</a>
        <ul>
            <li>sclpsolve('free_lp', lp)
            <li>lp is not changed as in the lpsolve API since it is a read_only input parameter. So it acts the same as delete_lp.</li>
        </ul>
    <li>
        <a href="get_anti_degen.htm">get_anti_degen</a>
        <ul>
            <li>return = sclpsolve('get_anti_degen', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_basis.htm">get_basis</a>
        <ul>
            <li>[bascolumn] = sclpsolve('get_basis', lp {,
    nonbasic})
            <li>The <i>bascolumn</i> argument in the API documentation is here the return value. The <i>nonbasic</i> argument is optional in Scilab. If not provided, then 0 is used.</li>
        </ul>
    <li>
        <a href="get_basiscrash.htm">get_basiscrash</a>
        <ul>
            <li>return = sclpsolve('get_basiscrash', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_bb_depthlimit.htm">get_bb_depthlimit</a>
        <ul>
            <li>return = sclpsolve('get_bb_depthlimit', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_bb_floorfirst.htm">get_bb_floorfirst</a>
        <ul>
            <li>return = sclpsolve('get_bb_floorfirst', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_bb_rule.htm">get_bb_rule</a>
        <ul>
            <li>return = sclpsolve('get_bb_rule', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_bounds_tighter.htm">get_bounds_tighter</a>
        <ul>
            <li>return = sclpsolve('get_bounds_tighter', lp)

            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_break_at_value.htm">get_break_at_value</a>
        <ul>
            <li>return = sclpsolve('get_break_at_value', lp)

            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_col_name.htm">get_col_name</a>
        <ul>
            <li>name = sclpsolve('get_col_name', lp, column)

            <li>[names] = sclpsolve('get_col_name', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_column.htm">get_column</a>
        <a href="get_column.htm">get_columnex</a>
        <ul>
            <li>[column, return] = sclpsolve('get_column', lp, col_nr)
            <li>[column, return] = sclpsolve('get_columnex', lp, col_nr)
            <li>The <i>column</i> argument in
    the API documentation is here the first return value.
            <li>The return code of the call is the second return value.</li>
        </ul>
    <li>
        <a href="get_constr_type.htm">get_constr_type</a>
        <ul>
            <li>return = sclpsolve('get_constr_type', lp,
    row)
            <li>[constr_type] = sclpsolve('get_constr_type',
    lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_constr_value.htm">get_constr_value</a>
        <ul>
            <li>return = sclpsolve('get_constr_value', lp, row {, primsolution})
            <li>The primsolution argument is optional. If not provided, then the solution of last solve is used.</li>
        </ul>
    <li>
        <a href="get_constraints.htm">get_constraints</a>
        <ul>
            <li>[constr, return] = sclpsolve('get_constraints',
    lp)
            <li>The <i>constr</i> argument in
    the API documentation is here the first return value.
            <li>The return code of the call is the second return value.</li>
        </ul>
    <li>
        <a href="get_sensitivity_rhs.htm">get_dual_solution</a>
        <ul>
            <li>[duals, return] = sclpsolve('get_dual_solution',
    lp)
            <li>The <i>duals</i> argument in
    the API documentation is here the first return value.
            <li>In the API, element 0 is not used and values start
    from element 1. In Scilab, there is no unused element in the matrix.
            <li>The return code of the call is the second return value.</li>
        </ul>
    <li>
        <a href="get_epsb.htm">get_epsb</a>
        <ul>
            <li>return = sclpsolve('get_epsb', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_epsd.htm">get_epsd</a>
        <ul>
            <li>return = sclpsolve('get_epsd', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_epsel.htm">get_epsel</a>
        <ul>
            <li>return = sclpsolve('get_epsel', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_epsint.htm">get_epsint</a>
        <ul>
            <li>return = sclpsolve('get_epsint', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_epsperturb.htm">get_epsperturb</a>
        <ul>
            <li>return = sclpsolve('get_epsperturb', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_epspivot.htm">get_epspivot</a>
        <ul>
            <li>return = sclpsolve('get_epspivot', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_improve.htm">get_improve</a>
        <ul>
            <li>return = sclpsolve('get_improve', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_infinite.htm">get_infinite</a>
        <ul>
            <li>return = sclpsolve('get_infinite', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_lowbo.htm">get_lowbo</a>
        <ul>
            <li>return = sclpsolve('get_lowbo', lp, column)
            <li>[return] = sclpsolve('get_lowbo', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_lp_index.htm">get_lp_index</a>
        <ul>
            <li>return = sclpsolve('get_lp_index', lp,
    orig_index)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_lp_name.htm">get_lp_name</a>
        <ul>
            <li>name = sclpsolve('get_lp_name', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_mat.htm">get_mat</a>
        <ul>
            <li>value = sclpsolve('get_mat', lp, row, col)
            <li>[matrix, return] = sclpsolve('get_mat', lp[, sparse])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix in the first return value.
                If sparse is different from zero then the returned matrix is a sparse matrix.
                The return code of the call is the second return value.</li>
        </ul>
    <li>
        <a href="get_max_level.htm">get_max_level</a>
        <ul>
            <li>return = sclpsolve('get_max_level', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_maxpivot.htm">get_maxpivot</a>
        <ul>
            <li>return = sclpsolve('get_maxpivot', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_mip_gap.htm">get_mip_gap</a>
        <ul>
            <li>return = sclpsolve('get_mip_gap', lp,
    absolute)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_nameindex.htm">get_nameindex</a>
        <ul>
            <li>return = sclpsolve('get_nameindex', lp, name, isrow)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_Ncolumns.htm">get_Ncolumns</a>
        <ul>
            <li>return = sclpsolve('get_Ncolumns', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_negrange.htm">get_negrange</a>
        <ul>
            <li>return = sclpsolve('get_negrange', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_nonzeros.htm">get_nonzeros</a>
        <ul>
            <li>return = sclpsolve('get_nonzeros', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_Norig_columns.htm">get_Norig_columns</a>
        <ul>
            <li>return = sclpsolve('get_Norig_columns', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_Norig_rows.htm">get_Norig_rows</a>
        <ul>
            <li>return = sclpsolve('get_Norig_rows', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_Nrows.htm">get_Nrows</a>
        <ul>
            <li>return = sclpsolve('get_Nrows', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_obj_bound.htm">get_obj_bound</a>
        <ul>
            <li>return = sclpsolve('get_obj_bound', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_objective.htm">get_objective</a>
        <ul>
            <li>return = sclpsolve('get_objective', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_orig_index.htm">get_orig_index</a>
        <ul>
            <li>return = sclpsolve('get_orig_index', lp,
    lp_index)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_col_name.htm">get_origcol_name</a>
        <ul>
            <li>name = sclpsolve('get_origcol_name', lp,
    column)
            <li>[names] = sclpsolve('get_origcol_name', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_row_name.htm">get_origrow_name</a>
        <ul>
            <li>name = sclpsolve('get_origrow_name', lp,
    row)
            <li>[names] = sclpsolve('get_origrow_name', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_pivoting.htm">get_pivoting</a>
        <ul>
            <li>return = sclpsolve('get_pivoting', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_presolve.htm">get_presolve</a>
        <ul>
            <li>return = sclpsolve('get_presolve', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_presolveloops.htm">get_presolveloops</a>
        <ul>
            <li>return = sclpsolve('get_presolveloops', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_primal_solution.htm">get_primal_solution</a>
        <ul>
            <li>[pv, return] = sclpsolve('get_primal_solution',
    lp)
            <li>The <i>pv</i> argument in the
    API documentation is here the first return value.
            <li>The return code of the call is the second return value.</li>
        </ul>
    <li>
        <a href="get_print_sol.htm">get_print_sol</a>
        <ul>
            <li>return = sclpsolve('get_print_sol', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_constraints.htm">get_ptr_constraints</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="get_sensitivity_rhs.htm">get_ptr_dualsolution</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="get_primal_solution.htm">get_ptr_primal_solution</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="get_sensitivity_obj.htm">get_ptr_sensitivity_obj, get_ptr_sensitivity_objex</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="get_sensitivity_rhs.htm">get_ptr_sensitivity_rhs</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="get_variables.htm">get_ptr_variables</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="get_rh.htm">get_rh</a>
        <ul>
            <li>return = sclpsolve('get_rh', lp, row)
            <li>[rh] = sclpsolve('get_rh', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_rh_range.htm">get_rh_range</a>
        <ul>
            <li>return = sclpsolve('get_rh_range', lp, row)
            <li>[rh_ranges] = sclpsolve('get_rh_range', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_row.htm">get_row</a>
        <a href="get_row.htm">get_rowex</a>
        <ul>
            <li>[row, return] = sclpsolve('get_row', lp, row_nr)
            <li>[row, return] = sclpsolve('get_rowex', lp, row_nr)
            <li>The <i>row</i> argument in the
    API documentation is here the first return value.
            <li>In the API, element 0 is not used and values start
    from element 1. In Scilab, there is no unused element in the matrix.
            <li>The return code of the call is the second return value.</li>
        </ul>
    <li>
        <a href="get_row_name.htm">get_row_name</a>
        <ul>
            <li>name = sclpsolve('get_row_name', lp, row)
            <li>[names] = sclpsolve('get_row_name', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_scalelimit.htm">get_scalelimit</a>
        <ul>
            <li>return = sclpsolve('get_scalelimit', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_scaling.htm">get_scaling</a>
        <ul>
            <li>return = sclpsolve('get_scaling', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_sensitivity_obj.htm">get_sensitivity_obj, get_sensitivity_objex</a>
        <ul>
            <li>[objfrom, objtill, objfromvalue, objtillvalue,
    return] = sclpsolve('get_sensitivity_obj', lp)
            <li>[objfrom, objtill, objfromvalue, objtillvalue,
    return] = sclpsolve('get_sensitivity_objex', lp)
            <li>The <i>objfrom</i>, <i>objtill</i>, <i>objfromvalue</i>, <i>objtillvalue</i> arguments in the API documentation
    are here the return values. Note that Scilab allows the return of fewer
    variables. For example if only objfrom and objtill are needed then the
    call can be [objfrom, objtill] = sclpsolve('get_sensitivity_obj',
    lp). The unrequested values are even not calculated.
            <li>Since the API routine doesn't calculate the <i>objtillvalue</i> value at this time, Scilab always
    returns a zero vector for this.
            <li>The return code of the call is the last value.
            <li>get_sensitivity_obj and get_sensitivity_objex are both implemented, but have the same functionality.</li>
        </ul>
    <li>
        <a href="get_sensitivity_rhs.htm">get_sensitivity_rhs, get_sensitivity_rhsex</a>
        <ul>
            <li>[duals, dualsfrom, dualstill, return] =
    sclpsolve('get_sensitivity_rhs', lp)
            <li>[duals, dualsfrom, dualstill, return] =
    sclpsolve('get_sensitivity_rhsex', lp)
            <li>The <i>duals</i>, <i>dualsfrom</i>, <i>dualstill</i>
    arguments in the API documentation are here the return values. Note that
    Scilab allows the return of fewer variables. For example if only duals is
    needed then the call can be [duals] = sclpsolve('get_sensitivity_rhs',
    lp). The unrequested values are even not calculated.
            <li>The return code of the call is the last value.
            <li>get_sensitivity_rhs and get_sensitivity_rhsex are both implemented, but have the same functionality.</li>
        </ul>
    <li>
        <a href="get_simplextype.htm">get_simplextype</a>
        <ul>
            <li>return = sclpsolve('get_simplextype', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_solutioncount.htm">get_solutioncount</a>
        <ul>
            <li>return = sclpsolve('get_solutioncount', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_solutionlimit.htm">get_solutionlimit</a>
        <ul>
            <li>return = sclpsolve('get_solutionlimit', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_status.htm">get_status</a>
        <ul>
            <li>return = sclpsolve('get_status', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_statustext.htm">get_statustext</a>
        <ul>
            <li>return = sclpsolve('get_statustext', lp,
    statuscode)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_timeout.htm">get_timeout</a>
        <ul>
            <li>return = sclpsolve('get_timeout', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_total_iter.htm">get_total_iter</a>
        <ul>
            <li>return = sclpsolve('get_total_iter', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_total_nodes.htm">get_total_nodes</a>
        <ul>
            <li>return = sclpsolve('get_total_nodes', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_upbo.htm">get_upbo</a>
        <ul>
            <li>return = sclpsolve('get_upbo', lp, column)
            <li>[upbo] = sclpsolve('get_upbo', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_var_branch.htm">get_var_branch</a>
        <ul>
            <li>return = sclpsolve('get_var_branch', lp,
    column)
            <li>[var_branch] = sclpsolve('get_var_branch',
    lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_sensitivity_rhs.htm">get_var_dualresult</a>
        <ul>
            <li>return = sclpsolve('get_var_dualresult', lp,
    index)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_primal_solution.htm">get_var_primalresult</a>
        <ul>
            <li>return = sclpsolve('get_var_primalresult',
    lp, index)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_var_priority.htm">get_var_priority</a>
        <ul>
            <li>return = sclpsolve('get_var_priority', lp,
    column)
            <li>[var_priority] = sclpsolve('get_var_priority',
    lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="get_variables.htm">get_variables</a>
        <ul>
            <li>[var, return] = sclpsolve('get_variables',
    lp)
            <li>The <i>var</i> argument in the
    API documentation is here the first return value.
            <li>The return code of the call is the second return value.</li>
        </ul>
    <li>
        <a href="get_verbose.htm">get_verbose</a>
        <ul>
            <li>return = sclpsolve('get_verbose', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="get_working_objective.htm">get_working_objective</a>
        <ul>
            <li>return = sclpsolve('get_working_objective',
    lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="guess_basis.htm">guess_basis</a>
        <ul>
            <li>[basisvector, return] = sclpsolve('guess_basis', lp, [guessvector])
            <li>In the API, element 0 of <i>guessvector</i> is not used and values start from element 1. In Scilab, there is no unused element in the matrix.</li>
            <li>In the API, element 0 of <i>basisvector</i> is not used and values start from element 1. In Scilab, there is no unused element in the matrix.</li>
        </ul>
    <li>
        <a href="has_BFP.htm">has_BFP</a>
        <ul>
            <li>return = sclpsolve('has_BFP', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="has_XLI.htm">has_XLI</a>
        <ul>
            <li>return = sclpsolve('has_XLI', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_add_rowmode.htm">is_add_rowmode</a>
        <ul>
            <li>return = sclpsolve('is_add_rowmode', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_anti_degen.htm">is_anti_degen</a>
        <ul>
            <li>return = sclpsolve('is_anti_degen', lp,
    testmask)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_binary.htm">is_binary</a>
        <ul>
            <li>return = sclpsolve('is_binary', lp, column)
            <li>[binary] = sclpsolve('is_binary', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="is_break_at_first.htm">is_break_at_first</a>
        <ul>
            <li>return = sclpsolve('is_break_at_first', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_constr_type.htm">is_constr_type</a>
        <ul>
            <li>return = sclpsolve('is_constr_type', lp,
    row, mask)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_debug.htm">is_debug</a>
        <ul>
            <li>return = sclpsolve('is_debug', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_feasible.htm">is_feasible</a>
        <ul>
            <li>return = sclpsolve('is_feasible', lp,
    [values] {, threshold})
            <li>The threshold argument is optional.
                When not provided, the value of <A href="get_epsint.htm">get_epsint</A> will be taken.</li>
        </ul>
    <li>
        <a href="is_unbounded.htm">is_free</a>
        <a href="is_unbounded.htm">is_unbounded</a>
        <ul>
            <li>return = sclpsolve('is_free', lp, column)
            <li>return = sclpsolve('is_unbounded', lp, column)
            <li>[free] = sclpsolve('is_free', lp)
            <li>[free] = sclpsolve('is_unbounded', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="is_infinite.htm">is_infinite</a>
        <ul>
            <li>return = sclpsolve('is_infinite', lp, value)

            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_int.htm">is_int</a>
        <ul>
            <li>return = sclpsolve('is_int', lp, column)
            <li>[int] = sclpsolve('is_int', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="is_integerscaling.htm">is_integerscaling</a>
        <ul>
            <li>return = sclpsolve('is_integerscaling', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_maxim.htm">is_maxim</a>
        <ul>
            <li>return = sclpsolve('is_maxim', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_nativeBFP.htm">is_nativeBFP</a>
        <ul>
            <li>return = sclpsolve('is_nativeBFP', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_nativeXLI.htm">is_nativeXLI</a>
        <ul>
            <li>return = sclpsolve('is_nativeXLI', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_negative.htm">is_negative</a>
        <ul>
            <li>return = sclpsolve('is_negative', lp,
    column)
            <li>[negative] = sclpsolve('is_negative', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="is_piv_mode.htm">is_piv_mode</a>
        <ul>
            <li>return = sclpsolve('is_piv_mode', lp,
    testmask)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_piv_rule.htm">is_piv_rule</a>
        <ul>
            <li>return = sclpsolve('is_piv_rule', lp, rule)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_presolve.htm">is_presolve</a>
        <ul>
            <li>return = sclpsolve('is_presolve', lp,
    testmask)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_scalemode.htm">is_scalemode</a>
        <ul>
            <li>return = sclpsolve('is_scalemode', lp,
    testmask)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_scaletype.htm">is_scaletype</a>
        <ul>
            <li>return = sclpsolve('is_scaletype', lp,
    scaletype)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_semicont.htm">is_semicont</a>
        <ul>
            <li>return = sclpsolve('is_semicont', lp,
    column)
            <li>[semicont] = sclpsolve('is_semicont', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="is_SOS_var.htm">is_SOS_var</a>
        <ul>
            <li>return = sclpsolve('is_SOS_var', lp, column)

            <li>[SOS_var] = sclpsolve('is_SOS_var', lp)
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows retrieving the values into a Scilab matrix.</li>
        </ul>
    <li>
        <a href="is_trace.htm">is_trace</a>
        <ul>
            <li>return = sclpsolve('is_trace', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="is_use_names.htm">is_use_names</a>
        <ul>
            <li>return = sclpsolve('is_use_names', lp, isrow)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="lp_solve_version.htm">lp_solve_version</a>
        <ul>
            <li>versionstring = sclpsolve('lp_solve_version')
            <li>The sclpsolve API routine returns the version information in 4 provided argument variables while the Scilab version returns the information as a string in the format major.minor.release.build</li>
        </ul>
    <li>
        <a href="make_lp.htm">make_lp</a>
        <ul>
            <li>lp_handle = sclpsolve('make_lp', rows, columns)
            <li>lp_handle is not a pointer to an lprec structure as in the API, but an incrementing handle number starting from 0.</li>
        </ul>
    <li>
        <a href="print_constraints.htm">print_constraints</a>
        <ul>
			<li>sclpsolve('print_constraints', lp {,
    columns})

			<li>columns is optional. If not specified, then 1 is
    used.

			<li>First call set_outputfile to specify where the
    information is written to. In the API documentation it is written that by
    default, the output goes to stdout, but under Scilab (Windows) this means
    that the output is not shown.
            <li>The same information can also be obtained via sclpsolve('get_constraints', lp). This shows the result on screen.</li>
        </ul>
    <li>
        <a href="print_debugdump.htm">print_debugdump</a>
        <ul>
            <li>return = sclpsolve('print_debugdump', lp,
    filename)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="print_duals.htm">print_duals</a>
        <ul>
			<li>sclpsolve('print_duals', lp)

			<li>First call set_outputfile to specify where the
    information is written to. In the API documentation it is written that by
    default, the output goes to stdout, but under Scilab (Windows) this means
    that the output is not shown.
            <li>The same information can be obtained via sclpsolve('get_dual_solution', lp). This shows the result on screen.</li>
        </ul>
    <li>
        <a href="print_lp.htm">print_lp</a>
        <ul>
			<li>sclpsolve('print_lp', lp)

			<li>First call set_outputfile to specify where the information is written to.
			    In the API documentation it is written that by default, the output goes to stdout, but under Scilab (Windows) this means that the output is not shown.</li>
        </ul>
    <li>
        <a href="print_objective.htm">print_objective</a>
        <ul>
			<li>sclpsolve('print_objective', lp)

			<li>First call set_outputfile to specify where the
    information is written to. In the API documentation it is written that by
    default, the output goes to stdout, but under Scilab (Windows) this means
    that the output is not shown.
            <li>The same information can be obtained via sclpsolve('get_objective', lp). This shows the result on screen.</li>
        </ul>
    <li>
        <a href="print_scales.htm">print_scales</a>
        <ul>
			<li>sclpsolve('print_scales', lp)

			<li>First call set_outputfile to specify where the information is written to.
			    In the API documentation it is written that by default, the output goes to stdout, but under Scilab (Windows) this means that the output is not shown.</li>
        </ul>
    <li>
        <a href="print_solution.htm">print_solution</a>
        <ul>
			<li>sclpsolve('print_solution', lp {, columns})

			<li>columns is optional. If not specified, then 1 is
    used.

			<li>First call set_outputfile to specify where the
    information is written to. In the API documentation it is written that by
    default, the output goes to stdout, but under Scilab (Windows) this means
    that the output is not shown.
            <li>The same information can also be obtained via sclpsolve('get_variables', lp). This shows the result on screen.</li>
        </ul>
    <li>
        <a href="print_str.htm">print_str</a>
        <ul>
			<li>sclpsolve('print_str', lp, str)

			<li>First call set_outputfile to specify where the information is written to.
			    In the API documentation it is written that by default, the output goes to stdout, but under Scilab (Windows) this means that the output is not shown.</li>
        </ul>
    <li>
        <a href="print_tableau.htm">print_tableau</a>
        <ul>
			<li>sclpsolve('print_tableau', lp)

			<li>First call set_outputfile to specify where the information is written to.
			    In the API documentation it is written that by default, the output goes to stdout, but under Scilab (Windows) this means that the output is not shown.</li>
        </ul>
    <li>
        <a href="put_abortfunc.htm">put_abortfunc</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="put_logfunc.htm">put_logfunc</a>
        <ul>
            <li>Not implemented.
            <li>However, the sclpsolve driver sets a log function to redirect the output of lpsolve from stdout (which is not visible in Windows Scilab) to the command window of Scilab.
                As such, all reported output can be seen in Scilab. How much output is seen is controlled by the verbose level that can be defined by set_verbose or can be specified in the read_ routines.</li>
        </ul>
    <li>
        <a href="put_msgfunc.htm">put_msgfunc</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="read_basis.htm">read_basis</a>
        <ul>
            <li>[ret, info] = sclpsolve('read_basis', lp, filename)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="read_mps.htm">read_freemps, read_freeMPS</a>
        <ul>
            <li>lp_handle = sclpsolve('read_freemps', filename {,
    options})
            <li>lp_handle = sclpsolve('read_freeMPS', filename {,
    options})
            <li>In the lpsolve API, read_freemps needs a FILE
    handle. In Scilab it needs the filename and thus acts the same as
    read_freeMPS.
            <li>lp_handle is not a pointer to an lprec structure as
    in the API, but an incrementing handle number starting from 0.
            <li>options is optional. If not specified, then NORMAL is used.</li>
        </ul>
    <li>
        <a name="read_lp"></a>
        <a href="read_lp.htm">read_lp, read_LP</a>
        <ul>
			<li>lp_handle = sclpsolve('read_lp', filename {,
    verbose {, lp_name}})
            <li>lp_handle = sclpsolve('read_LP', filename {,
    verbose {, lp_name}})
            <li>In the lpsolve API, read_lp needs a FILE handle. In
    Scilab it needs the filename and thus acts the same as read_LP.
            <li>lp_handle is not a pointer to an lprec structure as
    in the API, but an incrementing handle number starting from 0.
            <li>verbose is optional. If not provided then NORMAL is
    used.
            <li>lp_name is optional. If not provided then no name is given to the model ('').</li>
        </ul>
    <li>
        <a href="read_MPS.htm">read_mps, read_MPS</a>
        <ul>
			<li>lp_handle = sclpsolve('read_mps', filename {,
    options})
            <li>lp_handle = sclpsolve('read_MPS', filename {,
    options})
            <li>In the lpsolve API, read_mps needs a FILE handle.
    In Scilab it needs the filename and thus acts the same as read_MPS.
            <li>lp_handle is not a pointer to an lprec structure as
    in the API, but an incrementing handle number starting from 0.
            <li>options is optional. If not specified, then NORMAL is used.</li>
        </ul>
    <li>
        <a href="read_params.htm">read_params</a>
        <ul>
            <li>return = sclpsolve('read_params', lp, filename {, options })
            <li>options is optional.</li>
        </ul>
    <li>
        <a href="read_XLI.htm">read_XLI</a>
        <ul>
            <li>lp_handle = sclpsolve('read_XLI', xliname,
    modelname {, dataname {, options {, verbose}}}
            <li>lp_handle is not a pointer to an lprec structure as
    in the API, but an incrementing handle number starting from 0.
            <li>dataname is optional. When not provided, '' (NULL)
    is taken. '' is taken as NULL.
            <li>options is optional. When not provided, '' is
    taken.
            <li>verbose is optional. If not specified, then NORMAL is used.</li>
        </ul>
    <li>
        <a href="reset_basis.htm">reset_basis</a>
        <ul>
            <li>Not implemented.
            <li>Use <A href="default_basis.htm">default_basis</A></li>
        </ul>
    <li>
        <a href="set_basisvar.htm">set_basisvar</a>
        <ul>
            <li>sclpsolve('set_basisvar', lp, basisPos, enteringCol)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_add_rowmode.htm">set_add_rowmode</a>
        <ul>
            <li>return = sclpsolve('set_add_rowmode', lp,
    turnon)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_anti_degen.htm">set_anti_degen</a>
        <ul>
            <li>sclpsolve('set_anti_degen', lp, anti_degen)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_basis.htm">set_basis</a>
        <ul>
            <li>return = sclpsolve('set_basis', lp,
    [bascolumn], nonbasic)
            <li>In the API, element 0 of <i>bascolumn</i> is not used and values start from element 1. In Scilab, there is no unused element in the matrix.</li>
        </ul>
    <li>
        <a href="set_basiscrash.htm">set_basiscrash</a>
        <ul>
            <li>sclpsolve('set_basiscrash', lp, mode)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_bb_depthlimit.htm">set_bb_depthlimit</a>
        <ul>
            <li>sclpsolve('set_bb_depthlimit', lp,
    bb_maxlevel)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_bb_floorfirst.htm">set_bb_floorfirst</a>
        <ul>
            <li>sclpsolve('set_bb_floorfirst', lp,
    bb_floorfirst)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_bb_rule.htm">set_bb_rule</a>
        <ul>
            <li>sclpsolve('set_bb_rule', lp, bb_rule)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_BFP.htm">set_BFP</a>
        <ul>
            <li>return = sclpsolve('set_BFP', lp, filename)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_binary.htm">set_binary</a>
        <ul>
            <li>return = sclpsolve('set_binary', lp, column,
    must_be_bin)
            <li>return = sclpsolve('set_binary', lp,
    [must_be_bin])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a href="set_bounds.htm">set_bounds</a>
        <ul>
            <li>return = sclpsolve('set_bounds', lp, column,
    lower, upper)
            <li>return = sclpsolve('set_bounds', lp,
    [lower], [upper])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a href="set_bounds_tighter.htm">set_bounds_tighter</a>
        <ul>
            <li>sclpsolve('set_bounds_tighter', lp, tighten)

            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_break_at_first.htm">set_break_at_first</a>
        <ul>
            <li>sclpsolve('set_break_at_first', lp,
    break_at_first)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_break_at_value.htm">set_break_at_value</a>
        <ul>
            <li>sclpsolve('set_break_at_value', lp,
    break_at_value)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_col_name.htm">set_col_name</a>
        <ul>
            <li>return = sclpsolve('set_col_name', lp,
    column, name)
            <li>return = sclpsolve('set_col_name', lp,
    [names])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a href="set_column.htm">set_column, set_columnex</a>
        <ul>
            <li>return = sclpsolve('set_column', lp, col_no,
    [column])
            <li>return = sclpsolve('set_columnex', lp,
    col_no, [column])
            <li>Both have the same interface from <a href="set_column.htm">set_column</a> but act as <a href="set_column.htm">set_columnex</a></li>
        </ul>
    <li>
        <a href="set_constr_type.htm">set_constr_type</a>
        <ul>
            <li>return = sclpsolve('set_constr_type', lp,
    row, con_type)
            <li>return = sclpsolve('set_constr_type', lp,
    [con_type])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all rows.</li>
        </ul>
    <li>
        <a href="set_debug.htm">set_debug</a>
        <ul>
            <li>sclpsolve('set_debug', lp, debug)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_epsb.htm">set_epsb</a>
        <ul>
            <li>sclpsolve('set_epsb', lp, epsb)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_epsd.htm">set_epsd</a>
        <ul>
            <li>sclpsolve('set_epsd', lp, epsd)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_epsel.htm">set_epsel</a>
        <ul>
            <li>sclpsolve('set_epsel', lp, epsel)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_epsint.htm">set_epsint</a>
        <ul>
            <li>sclpsolve('set_epsint', lp, epsint)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_epslevel.htm">set_epslevel</a>
        <ul>
            <li>sclpsolve('set_epslevel', lp, epslevel)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_epsperturb.htm">set_epsperturb</a>
        <ul>
            <li>sclpsolve('set_epsperturb', lp, epsperturb)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_epspivot.htm">set_epspivot</a>
        <ul>
            <li>sclpsolve('set_epspivot', lp, epspivot)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_unbounded.htm">set_free</a>
        <a href="set_unbounded.htm">set_unbounded</a>
        <ul>
            <li>return = sclpsolve('set_free', lp, column)
            <li>return = sclpsolve('set_unbounded', lp, column)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_improve.htm">set_improve</a>
        <ul>
            <li>sclpsolve('set_improve', lp, improve)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_infinite.htm">set_infinite</a>
        <ul>
            <li>sclpsolve('set_infinite', lp, infinite)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_int.htm">set_int</a>
        <ul>
            <li>return = sclpsolve('set_int', lp, column,
    must_be_int)
            <li>return = sclpsolve('set_int', lp,
    [must_be_int])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a href="set_lowbo.htm">set_lowbo</a>
        <ul>
            <li>return = sclpsolve('set_lowbo', lp, column,
    value)
            <li>return = sclpsolve('set_lowbo', lp,
    [values])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a name="set_lp_name"></a>
        <a href="set_lp_name.htm">set_lp_name</a>
        <ul>
            <li>return = sclpsolve('set_lp_name', lp, name)
            <li>In Scilab, when you name a model, this name can be used everywhere where lp is specified.
                This to access the model via the name instead of via a handle.</li>
        </ul>
    <li>
        <a href="set_mat.htm">set_mat</a>
        <ul>
            <li>return = sclpsolve('set_mat', lp, row,
    column, value)
            <li>return = sclpsolve('set_mat', lp, [matrix])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows to set the whole matrix (all rows/columns) at once.
                This is the most performant way to provide the constraint matrix. Consider using a Scilab sparse matrix for maximum performance and least memory usage.
                The matrix must be two-dimentional.</li>
        </ul>
    <li>
        <a href="set_maxim.htm">set_maxim</a>
        <ul>
            <li>sclpsolve('set_maxim', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_maxpivot.htm">set_maxpivot</a>
        <ul>
            <li>sclpsolve('set_maxpivot', max_num_inv)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_minim.htm">set_minim</a>
        <ul>
            <li>sclpsolve('set_minim', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_mip_gap.htm">set_mip_gap</a>
        <ul>
            <li>sclpsolve('set_mip_gap', lp, absolute,
    mip_gap)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_negrange.htm">set_negrange</a>
        <ul>
            <li>sclpsolve('set_negrange', negrange)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_obj_fn.htm">set_obj</a>
        <ul>
            <li>return = sclpsolve('set_obj', lp, column,
    value)
            <li>return = sclpsolve('set_obj', lp, [values])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables. It is then the same as set_obj_fn</li>
        </ul>
    <li>
        <a href="set_obj_bound.htm">set_obj_bound</a>
        <ul>
            <li>sclpsolve('set_obj_bound', lp, obj_bound)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_obj_fn.htm">set_obj_fn, set_obj_fnex</a>
        <ul>
            <li>return = sclpsolve('set_obj_fn', lp, [row])
            <li>return = sclpsolve('set_obj_fnex', lp,
    [row])
            <li>Both have the same interface from <a href="set_obj_fn.htm">set_obj_fn</a> but act as <a href="set_obj_fn.htm">set_obj_fnex</a>
            <li>In the API, element 0 is not used and values start from element 1. In Scilab, there is no unused element in the matrix.</li>
        </ul>
    <li>
        <a href="set_output.htm">set_outputfile</a>
        <ul>
            <li>return = sclpsolve('set_outputfile', lp,
    filename)
            <li>In the API description it says that setting filename to NULL results in writing output back to stdout.
                In Scilab under Windows, output to stdout it not shown. However it results in closing the file.
                Use '' to have the effect of NULL.</li>
        </ul>
    <li>
        <a href="set_output.htm">set_outputstream</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="set_pivoting.htm">set_pivoting</a>
        <ul>
            <li>sclpsolve('set_pivoting', lp, pivoting)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_preferdual.htm">set_preferdual</a>
        <ul>
            <li>sclpsolve('set_preferdual', lp, dodual)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_presolve.htm">set_presolve</a>
        <ul>
            <li>sclpsolve('set_presolve', lp, do_presolve {, maxloops})
            <li>The <i>maxloops</i> argument is optional in Scilab. If not provided, then infinite is used.</li>
        </ul>
    <li>
        <a href="set_print_sol.htm">set_print_sol</a>
        <ul>
            <li>sclpsolve('set_print_sol', lp, print_sol)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_rh.htm">set_rh</a>
        <ul>
            <li>return = sclpsolve('set_rh', lp, row, value)

            <li>return = sclpsolve('set_rh', lp, [values])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all rows. Note that in this case, the value of row 0 is not specified in the matrix.</li>
        </ul>
    <li>
        <a href="set_rh_range.htm">set_rh_range</a>
        <ul>
            <li>return = sclpsolve('set_rh_range', lp, row,
    deltavalue)
            <li>return = sclpsolve('set_rh_range', lp,
    [deltavalues])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all rows.</li>
        </ul>
    <li>
        <a href="set_rh_vec.htm">set_rh_vec</a>
        <ul>
            <li>sclpsolve('set_rh_vec', lp, [rh])
            <li>In the API, element 0 is not used and values start from element 1. In Scilab, there is no unused element in the matrix.</li>
        </ul>
    <li>
        <a href="set_row.htm">set_row, set_rowex</a>
        <ul>
            <li>return = sclpsolve('set_row', lp, row_no,
    [row])
            <li>return = sclpsolve('set_rowex', lp, row_no,
    [row])
            <li>Both have the same interface from <a href="set_row.htm">set_row</a> but act as <a href="set_row.htm">set_rowex</a>
            <li>In the API, element 0 is not used and values start from element 1. In Scilab, there is no unused element in the matrix.</li>
        </ul>
    <li>
        <a href="set_row_name.htm">set_row_name</a>
        <ul>
            <li>return = sclpsolve('set_row_name', lp, row,
    name)
            <li>return = sclpsolve('set_row_name', lp,
    [names])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all rows.</li>
        </ul>
    <li>
        <a href="set_scalelimit.htm">set_scalelimit</a>
        <ul>
            <li>sclpsolve('set_scalelimit', lp, scalelimit)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_scaling.htm">set_scaling</a>
        <ul>
            <li>sclpsolve('set_scaling', lp, scalemode)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_semicont.htm">set_semicont</a>
        <ul>
            <li>return = sclpsolve('set_semicont', lp,
    column, must_be_sc)
            <li>return = sclpsolve('set_semicont', lp,
    [must_be_sc])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a href="set_sense.htm">set_sense</a>
        <ul>
            <li>sclpsolve('set_sense', lp, maximize)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_simplextype.htm">set_simplextype</a>
        <ul>
            <li>sclpsolve('set_simplextype', lp,
    simplextype)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_solutionlimit.htm">set_solutionlimit</a>
        <ul>
            <li>sclpsolve('set_solutionlimit', lp,
    simplextype)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_timeout.htm">set_timeout</a>
        <ul>
            <li>sclpsolve('set_timeout', lp, sectimeout)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_trace.htm">set_trace</a>
        <ul>
            <li>sclpsolve('set_trace', lp, trace)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_upbo.htm">set_upbo</a>
        <ul>
            <li>return = sclpsolve('set_upbo', lp, column,
    value)
            <li>return = sclpsolve('set_upbo', lp, [values])

            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a href="set_use_names.htm">set_use_names</a>
        <ul>
            <li>sclpsolve('set_use_names', lp, isrow, use_names)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_var_branch.htm">set_var_branch</a>
        <ul>
            <li>return = sclpsolve('set_var_branch', lp,
    column, branch_mode)
            <li>return = sclpsolve('set_var_branch', lp,
    [branch_mode])
            <li>In Scilab, this routine has two formats. The first format is identical to the API.
                The second format allows setting a matrix of all variables.</li>
        </ul>
    <li>
        <a href="set_var_weights.htm">set_var_weights</a>
        <ul>
            <li>return = sclpsolve('set_var_weights', lp,
    [weights])
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_verbose.htm">set_verbose</a>
        <ul>
            <li>sclpsolve('set_verbose', lp, verbose)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="set_XLI.htm">set_XLI</a>
        <ul>
            <li>return = sclpsolve('set_XLI', lp, filename)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="solve.htm">solve</a>
        <ul>
            <li>result = sclpsolve('solve', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="add_column.htm">str_add_column</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="add_constraint.htm">str_add_constraint</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="set_obj_fn.htm">str_set_obj_fn</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="set_rh_vec.htm">str_set_rh_vec</a>
        <ul>
            <li>Not implemented.</li>
        </ul>
    <li>
        <a href="time_elapsed.htm">time_elapsed</a>
        <ul>
            <li>return = sclpsolve('time_elapsed', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="unscale.htm">unscale</a>
        <ul>
            <li>sclpsolve('unscale', lp)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="write_basis.htm">write_basis</a>
        <ul>
            <li>sclpsolve('write_basis', lp, filename)
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="write_mps.htm">write_freemps, write_freeMPS</a>
        <ul>
            <li>return = sclpsolve('write_freemps', lp,
    filename)
            <li>return = sclpsolve('write_freeMPS', lp,
    filename)
            <li>In the lpsolve API, write_freeMPS needs a FILE handle. In Scilab it needs the filename and thus acts the same as write_freemps.</li>
        </ul>
    <li>
        <a href="write_lp.htm">write_lp, write_LP</a>
        <ul>
            <li>return = sclpsolve('write_lp', lp, filename)

            <li>return = sclpsolve('write_LP', lp, filename)

            <li>In the lpsolve API, write_LP needs a FILE handle. In Scilab it needs the filename and thus acts the same as write_lp.</li>
        </ul>
    <li>
        <a href="write_mps.htm">write_mps, write_MPS</a>
        <ul>
            <li>return = sclpsolve('write_mps', lp,
    filename)
            <li>return = sclpsolve('write_MPS', lp,
    filename)
            <li>In the lpsolve API, write_MPS needs a FILE handle.
    In Scilab it needs the filename and thus acts the same as write_mps.
            <li>No special considerations.</li>
        </ul>
    <li>
        <a href="write_XLI.htm">write_XLI</a>
        <ul>
            <li>return = sclpsolve('write_XLI', lp, filename
    {, options {, results}})
            <li>No special considerations.</li>
        </ul>
    </li>
</ul>

<a name="Extra_Scilab_routines"></a>
<h3>Extra Scilab routines</h3>

<p>These routines are not part of the lpsolve API, but are added for backwards compatibility.
Most of them exist in the lpsolve API with another name.</p>

<ul>
	<li>[names] = sclpsolve('get_col_names', lp)
        <ul>
            <li>The same as get_col_name. Implemented for backwards compatibility.</li>
        </ul>
	<li>[constr_type] = sclpsolve('get_constr_types', lp)
        <ul>
            <li>The same as get_constr_type. Implemented for backwards compatibility.</li>
        </ul>
    <li>[int] = sclpsolve('get_int', lp)
        <ul>
            <li>The same as is_int. Implemented for backwards compatibility.</li>
        </ul>
    <li>return = sclpsolve('get_no_cols', lp)
        <ul>
            <li>The same as get_Ncolumns. Implemented for backwards compatibility.</li>
        </ul>
    <li>return = sclpsolve('get_no_rows', lp)
        <ul>
            <li>The same as get_Nrows. Implemented for backwards compatibility.</li>
        </ul>
    <li>name = sclpsolve('get_objective_name', lp)
        <ul>
            <li>The same as get_row_name with row=0. Implemented for backwards compatibility.</li>
        </ul>
    <li>[row_vec, return] = sclpsolve('get_obj_fn', lp)<br>
        [row_vec, return] =

           sclpsolve('get_obj_fun', lp)
        <ul>
            <li>The same as get_row with row 0. Implemented for backwards compatibility.</li>
        </ul>
    <li>name = sclpsolve('get_problem_name', lp)
        <ul>
            <li>The same as get_lp_name. Implemented for backwards compatibility.</li>
        </ul>
    <li>[costs] = sclpsolve('get_reduced_costs', lp)
        <ul>
            <li>The same as get_dual_solution. Implemented for backwards compatibility.</li>
        </ul>
	<li>[names] = sclpsolve('get_row_names', lp)
        <ul>
            <li>The same as get_row_name. Implemented for backwards compatibility.</li>
        </ul>
    <li>[obj, x, duals, return] = sclpsolve('get_solution', lp)
        <ul>
            <li>Returns the value of the objective function, the
    values of the variables and the duals. Implemented for backwards
    compatibility.
            <li>The return code of the call is the last value.</li>
        </ul>
    <li>value = sclpsolve('mat_elm', lp)
        <ul>
            <li>The same as get_mat. Implemented for backwards compatibility.</li>
        </ul>
    <li>[handle_vec] = sclpsolve('print_handle')
        <ul>
            <li>Returns a vector with open handles.
                Can be handy to see which handles aren't closed yet with delete_lp or free_lp.</li>
        </ul>
    <li>lp_handle = sclpsolve('read_lp_file', filename {, verbose {, lp_name}})
        <ul>
            <li>The same as read_LP. Implemented for backwards compatibility.</li>
        </ul>
    </li>
    <li><a name="get_handle"></a>lp_handle = sclpsolve('get_handle', lp_name)
        <ul>
            <li>Get the handle for this model from the models name.
                If an unknown model name is given (or already deleted), -1 is returned.
            </li>
       </ul>
    </li>
    <li><a name="return_constants"></a>return_constants = sclpsolve('return_constants'[, return_constants])
        <ul>
            <li>Returns the setting of return_constants and optionally sets its value.
            </li>
       </ul>
    </li>
</ul>

<a name="Compile_the_sclpsolve_driver"></a>
<h3>Compile the sclpsolve driver</h3>
<h4>Windows, Unix/Linux</h4>

<p>Under Windows, the sclpsolve Scilab driver is a dll: sclpsolve.dll<br>
Under Unix/Linux, the sclpsolve Scilab driver is a static library sclpsolve.a<br>
The library is an interface to the lpsolve55 library that contains the implementation of lp_solve.
Under windows this is a dll lpsolve55.dll and under Unix/Linux it is a shared library liblpsolve55.so<br>
They are distributed with the lp_solve package (archive lp_solve_5.5.2.14_dev.zip/lp_solve_5.5.2.14_dev.tar.gz). See at the beginning of this article where these files must be installed.
The sclpsolve Scilab driver is just
a wrapper between Scilab and lp_solve to translate the input/output to/from Scilab and the lp_solve library.
</p>

<p>The sclpsolve Scilab driver is written in C. To compile this code, under Windows the Microsoft C compiler is needed and under
Unix the standard compiler is used.<br>
This compiler must be called from Scilab. To make the compilation process easier, a script can be used:
builder.sce<br>
<!--
Before the compilation is started, it may be necessary to edit the file Path.incl. In this file it is specified where scilab is installed
and were lp_solve is installed. Change the paths as needed.<br>
//-->
To make everything, just enter exec builder.sce and everything is build.<br>
This compiles the source files to the needed libraries, compiles the sci scripts and makes the manuals. It also
generates a new loader.sce file to load the driver into the Scilab workspace.
</p>

<p>This build process is the same under Windows and Unix/Linux. Note that builder.sce generates Makefiles that
are then used to build the code. Don't edit the Makefiles since your changes will be lost when build.sce is
executed again.</p>

<p>See also <a href="MATLAB.htm">Using lpsolve from MATLAB</a>,
            <a href="O-Matrix.htm">Using lpsolve from O-Matrix</a>,
            <a href="Sysquake.htm">Using lpsolve from Sysquake</a>,
            <a href="Octave.htm">Using lpsolve from Octave</a>,
            <a href="FreeMat.htm">Using lpsolve from FreeMat</a>,
            <a href="Euler.htm">Using lpsolve from Euler</a>,
            <a href="Python.htm">Using lpsolve from Python</a>,
            <a href="Sage.htm">Using lpsolve from Sage</a>,
            <a href="PHP.htm">Using lpsolve from PHP</a>,
            <a href="R.htm">Using lpsolve from R</a>,
            <a href="MSF.htm">Using lpsolve from Microsoft Solver Foundation</a>
</p>
	</BODY>
</html>
